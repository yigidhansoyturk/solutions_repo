{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: Range vs Angle body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 1000px; padding: 0 20px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } input[type=\"range\"], input[type=\"number\"] { width: 200px; margin-right: 10px; } #controls label { font-weight: bold; margin-right: 10px; } #plot { margin-top: 20px; } pre { background: #f4f4f4; padding: 10px; overflow-x: auto; } ul { margin-top: 0; } /* Style for formulas to keep the size consistent */ .formula { font-size: 1.5em; font-family: 'Times New Roman', Times, serif; font-weight: bold; text-align: center; margin: 20px 0; color: #e74c3c; } /* Small formulas for inline usage */ .small-formula { font-size: 1.2em; font-family: 'Times New Roman', Times, serif; font-weight: normal; text-align: center; margin: 10px 0; color: #333; } \ud83d\ude80 Investigating Range vs Angle in Projectile Motion A projectile launched at an angle \u03b8 and initial speed v\u2080 follows a parabolic path under gravity. Assuming flat terrain and no air resistance, the horizontal range is given by the equation: \\( R = \\frac{{v_0^2 \\cdot \\sin(2\\theta)}}{g} \\) This is derived from the motion's horizontal and vertical components: \\( v_x = v_0 \\cdot \\cos(\\theta) \\) (horizontal component) \\( v_y = v_0 \\cdot \\sin(\\theta) \\) (vertical component) \\( \\text{Time of flight} = \\frac{2 \\cdot v_y}{g} \\) \\( \\text{Range} = v_x \\cdot \\text{time} \\) At an ideal launch angle of 45\u00b0, the range reaches its maximum value. We will explore how the range varies with different angles and initial velocities. \ud83e\uddea Simulation Controls Initial Velocity (v\u2080): 30 m/s Gravity (g): m/s\u00b2 Launch Height (h\u2080): meters \ud83d\udcca Graph Interpretation The plot shows how the horizontal range varies with angle for a given set of conditions. When height is zero, the range is maximized at 45\u00b0. If you increase height, this symmetry is broken. Higher velocities stretch the curve upwards. \ud83c\udf0d Real-World Considerations The model assumes: Flat launch/landing height No air resistance Still air and no spin In real scenarios, these factors matter: Air drag: slows the projectile and reduces range Launch height: longer flight time, increases range Wind: adds or subtracts from velocity Magnus effect: from spin, curves the path These effects require more complex models, typically solved numerically or via simulations. // Function to compute range based on initial velocity, gravity, launch angle, and height function computeRange(v0, g, angleDeg, h0) { const theta = angleDeg * Math.PI / 180; // Convert angle to radians const v0x = v0 * Math.cos(theta); // Horizontal velocity const v0y = v0 * Math.sin(theta); // Vertical velocity // Time of flight with height: solve the quadratic equation for time const t_flight = (v0y + Math.sqrt(v0y * v0y + 2 * g * h0)) / g; return v0x * t_flight; // Range = horizontal velocity * time of flight } // Function to update the plot based on user input function updateAll() { const v0 = parseFloat(document.getElementById('v0').value); // Get velocity from input const g = parseFloat(document.getElementById('gravity').value); // Get gravity from input const h0 = parseFloat(document.getElementById('height').value); // Get height from input document.getElementById('v0Val').textContent = v0; // Update displayed value of v\u2080 const angles = []; // Array for angles const ranges = []; // Array for corresponding ranges // Calculate the range for angles from 0\u00b0 to 90\u00b0 (in increments of 0.5\u00b0) for (let theta = 0; theta <= 90; theta += 0.5) { angles.push(theta); ranges.push(computeRange(v0, g, theta, h0)); } // Plot the range vs angle const trace = { x: angles, y: ranges, type: 'scatter', mode: 'lines', line: { color: 'royalblue', width: 3 }, name: `v\u2080 = ${v0} m/s` }; // Plot layout const layout = { title: 'Range vs Angle of Projection', xaxis: { title: 'Angle (degrees)' }, yaxis: { title: 'Range (meters)' } }; Plotly.newPlot('plot', [trace], layout); // Plot using Plotly } // Initialize the plot with default values updateAll();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Simulator body { font-family: Arial, sans-serif; margin: 0 auto; max-width: 1000px; padding: 20px; background-color: #fefefe; color: #333; line-height: 1.6; overflow-x: hidden; /* Sayfa kaymas\u0131n\u0131 engellemek i\u00e7in */ } h1, h2, h3 { color: #2c3e50; } .controls input { margin: 5px 10px; } .scenario-btn { margin: 15px 5px; padding: 8px 15px; cursor: pointer; background-color: #f0f0f0; border: 1px solid #ccc; font-size: 14px; } #plot { margin-top: 30px; } code { background: #f4f4f4; padding: 3px 6px; border-radius: 4px; } h2 { font-size: 1.4em; /* Ba\u015fl\u0131k boyutunu k\u00fc\u00e7\u00fcltme */ } .scenario-btn { font-size: 16px; } \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 Theoretical Foundation The forced damped pendulum is governed by the nonlinear second-order differential equation: \\( \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\) Here: \\( \\theta \\) : Angular displacement \\( b \\) : Damping coefficient \\( L \\) : Length of pendulum \\( A \\) : Driving amplitude \\( \\omega \\) : Driving angular frequency This system can exhibit a wide variety of behaviors: from simple oscillations to chaotic motion. \ud83c\udf9b Simulation Controls Damping (b): Amplitude (A): Omega (\u03c9): Length (L): \u03b8\u2080: \u03b8\u0307\u2080: Run Simulation \ud83d\udca1 Example Scenarios: Periodic (b=0.2, A=1.2, \u03c9=2.0) Resonance (b=0.05, A=0.9, \u03c9\u2248\u221a(g/L)) Chaotic (b=0.1, A=1.5, \u03b8\u2080=1.5) \ud83d\udcca What You See on the Graph The plot below shows the angular displacement \\( \\theta(t) \\) over time, based on the chosen parameters. By changing the damping, driving amplitude, and frequency, you can observe transitions between regular and chaotic motion. function pendulumODE(t, state, b, g, L, A, omega) { const [theta, v] = state; return [v, -b * v - (g / L) * Math.sin(theta) + A * Math.cos(omega * t)]; } function rungeKutta(f, y0, t0, dt, steps, params) { let t = t0; let y = y0; const result = [[t, ...y]]; for (let i = 0; i < steps; i++) { const k1 = f(t, y, ...params); const k2 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k1[j]), ...params); const k3 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k2[j]), ...params); const k4 = f(t + dt, y.map((yi, j) => yi + dt * k3[j]), ...params); y = y.map((yi, j) => yi + dt / 6 * (k1[j] + 2*k2[j] + 2*k3[j] + k4[j])); t += dt; result.push([t, ...y]); } return result; } function runSimulation() { const b = parseFloat(document.getElementById('b').value); const A = parseFloat(document.getElementById('A').value); const omega = parseFloat(document.getElementById('omega').value); const L = parseFloat(document.getElementById('L').value); const theta0 = parseFloat(document.getElementById('theta0').value); const v0 = parseFloat(document.getElementById('v0').value); const data = rungeKutta(pendulumODE, [theta0, v0], 0, 0.05, 1000, [b, 9.81, L, A, omega]); const t = data.map(d => d[0]); const theta = data.map(d => d[1]); Plotly.newPlot('plot', [{ x: t, y: theta, type: 'scatter', mode: 'lines', line: { color: 'blue' } }], { title: 'Angular Displacement Over Time', xaxis: { title: 'Time (s)' }, yaxis: { title: '\u03b8 (rad)' } }); } function loadScenario(type) { if (type === 'periodic') { document.getElementById('b').value = 0.2; document.getElementById('A').value = 1.2; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"This example shows periodic behavior with light damping and moderate forcing. The pendulum synchronizes with the driving force.\"; } else if (type === 'resonance') { document.getElementById('b').value = 0.05; document.getElementById('A').value = 0.9; document.getElementById('omega').value = 3.13; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"Here the driving frequency matches the system's natural frequency, causing resonance and increasing amplitude dramatically.\"; } else if (type === 'chaotic') { document.getElementById('b').value = 0.1; document.getElementById('A').value = 1.5; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 1.5; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"With strong forcing and large initial angle, the motion becomes chaotic. Even tiny changes lead to very different outcomes.\"; } runSimulation(); } runSimulation();","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Kepler's Third Law: Orbital Mechanics body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; background: #f9f9f9; color: #222; transition: background 0.4s, color 0.4s; } .dark-mode { background: #121212; color: #f0f0f0; } h1, h2 { color: #003366; } .dark-mode h1, .dark-mode h2 { color: #66ccff; } section { background: #fff; padding: 20px; margin: 20px 0; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); transition: background 0.4s, color 0.4s; } .dark-mode section { background: #1e1e1e; box-shadow: 0 0 10px rgba(255, 255, 255, 0.05); } canvas { margin-top: 20px; } button { margin-bottom: 20px; padding: 10px 20px; font-size: 14px; cursor: pointer; border: none; border-radius: 5px; background-color: #003366; color: white; transition: background 0.3s; } .dark-mode button { background-color: #66ccff; color: #000; } #orbit3D { width: 100%; height: 400px; margin-top: 20px; } Toggle Dark Mode Kepler's Third Law and Orbital Mechanics Overview Kepler's Third Law is one of the foundational principles of celestial mechanics. It states that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\). This elegant relationship reveals the connection between time and space in orbital systems and allows astronomers to calculate planetary motions, design satellite orbits, and explore gravitational dynamics. It provides the framework for understanding how bodies move under the influence of gravity, from moons orbiting planets to entire planetary systems orbiting stars. Derivation From Newton's laws: \\[ F = \\frac{G M m}{r^2} \\quad \\text{and} \\quad F = \\frac{m v^2}{r} \\] Equating the forces and substituting for \\( v = \\frac{2 \\pi r}{T} \\): \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This shows \\( T^2 \\propto r^3 \\). Python Simulation (Code Explanation) The following Python code computes orbital periods for various radii and verifies Kepler's law: import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth's mass radii = np.linspace(7e6, 4.2e7, 100) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) plt.plot(radii**3, periods**2) plt.title(\"Kepler's Law: T^2 vs r^3\") plt.xlabel(\"r^3 (m^3)\") plt.ylabel(\"T^2 (s^2)\") plt.grid(True) plt.show() Visualization const G = 6.67430e-11; const M = 5.972e24; const radii = Array.from({length: 100}, (_, i) => 7e6 + i * (4.2e7 - 7e6) / 99); const r3 = radii.map(r => r ** 3); const T2 = radii.map(r => Math.pow(2 * Math.PI * Math.sqrt(r ** 3 / (G * M)), 2)); const ctx = document.getElementById('keplerChart').getContext('2d'); new Chart(ctx, { type: 'line', data: { labels: r3, datasets: [{ label: 'T\u00b2 vs r\u00b3', data: T2, borderColor: 'blue', borderWidth: 2, fill: false }] }, options: { responsive: true, animation: { duration: 1500, easing: 'easeOutBounce' }, scales: { x: { type: 'linear', title: { display: true, text: 'r\u00b3 (m\u00b3)' } }, y: { title: { display: true, text: 'T\u00b2 (s\u00b2)' } } } } }); Orbital Concepts Illustration While 3D animation can be insightful, here we illustrate orbital concepts through simpler and more stable methods: Proportionality of \\( T^2 \\) and \\( r^3 \\): Verified through mathematical derivation and simulation. Circular vs. Elliptical Orbits: Circular orbits simplify calculations, but Kepler's law holds for elliptical orbits using the semi-major axis. Real-World Relevance: Used in space mission planning, satellite launches, and estimating planetary masses. Discussion Kepler's Third Law not only simplifies the analysis of orbital systems but also lays the foundation for space travel and astrophysics. It can be extended to elliptical orbits by using the semi-major axis in place of radius. function toggleDarkMode() { document.body.classList.toggle('dark-mode'); }","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities body { font-family: Arial, sans-serif; margin: 20px; background-color: #f9f9f9; color: #222; transition: background 0.4s, color 0.4s; } .dark-mode { background-color: #121212; color: #f0f0f0; } button { padding: 10px 20px; margin-bottom: 20px; background-color: #003366; color: white; border: none; border-radius: 5px; cursor: pointer; } .dark-mode button { background-color: #66ccff; color: #000; } section { background: #fff; padding: 20px; margin: 20px 0; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); } .dark-mode section { background: #1e1e1e; box-shadow: 0 0 10px rgba(255,255,255,0.05); } Toggle Dark Mode Escape Velocities and Cosmic Velocities Overview The concept of escape velocity is crucial in astrodynamics. It defines the minimum speed needed for an object to escape the gravitational field of a body without further propulsion. Extending from this are the first, second, and third cosmic velocities: First Cosmic Velocity \u2013 orbital velocity to maintain a stable circular orbit. Second Cosmic Velocity \u2013 escape velocity from a planet's gravitational field. Third Cosmic Velocity \u2013 velocity required to leave the solar system. These concepts form the basis for understanding satellite launches, planetary exploration, and interstellar mission design. Mathematical Derivations Starting from energy conservation, escape velocity \\( v_e \\) is derived by setting kinetic energy equal to gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v_e = \\sqrt{\\frac{2GM}{r}} \\] Similarly, orbital velocity \\( v_o \\): \\[ v_o = \\sqrt{\\frac{GM}{r}} \\] The third cosmic velocity depends on both planetary and solar gravitational fields. Python Code: Calculate and Compare import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.39e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7}, } for name, data in celestial_bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) print(f\"{name}: First = {v1:.2f} m/s, Second = {v2:.2f} m/s\") Visualization const labels = ['Earth', 'Mars', 'Jupiter']; const firstCosmic = [7900, 3500, 42000]; const secondCosmic = [11200, 5000, 60000]; new Chart(document.getElementById('velocityChart').getContext('2d'), { type: 'bar', data: { labels: labels, datasets: [ { label: 'First Cosmic Velocity (m/s)', data: firstCosmic, backgroundColor: 'blue' }, { label: 'Second Cosmic Velocity (m/s)', data: secondCosmic, backgroundColor: 'red' } ] }, options: { responsive: true, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (m/s)' } } } } }); Discussion and Application These velocities have direct implications in: Satellite deployment and orbital stability. Designing missions to escape Earth's gravity and travel to other planets. Planning interstellar trajectories that may one day leave our solar system. function toggleDarkMode() { document.body.classList.toggle('dark-mode'); }","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; color: #222; transition: background 0.3s, color 0.3s; } .dark-mode { background-color: #121212; color: #eee; } section { background: #fff; margin: 20px 0; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); transition: background 0.3s, color 0.3s; } .dark-mode section { background: #1e1e1e; } h1, h2 { color: #003366; } .dark-mode h1, .dark-mode h2 { color: #66ccff; } button, select { margin: 10px 10px 20px 0; padding: 10px; border: none; border-radius: 5px; background-color: #003366; color: white; font-size: 14px; cursor: pointer; } .dark-mode button, .dark-mode select { background-color: #66ccff; color: #000; } Toggle Dark Mode 7000 m/s (Suborbital) 7700 m/s (Orbital) 11200 m/s (Escape) Trajectories of a Freely Released Payload Near Earth Overview When a payload is released near Earth from a moving object such as a rocket, its trajectory is governed by the principles of orbital mechanics and gravitational physics. The motion depends critically on the initial conditions \u2014 namely, the payload's velocity, direction, and altitude. Depending on these initial parameters, the payload can follow a range of paths: it may re-enter the atmosphere (suborbital), achieve a stable circular or elliptical orbit (orbital), or escape Earth's gravity completely (hyperbolic escape trajectory). Each of these outcomes is associated with a specific energy regime and is predictable using Newtonian physics and numerical integration methods. This simulation framework allows us to explore these possibilities by adjusting the initial launch speed. Suborbital speeds result in a curved path back to Earth, orbital velocities allow continuous revolution, and escape velocities let the payload move away indefinitely. This mirrors real mission scenarios such as deploying satellites (orbital), sounding rockets (suborbital), and interplanetary probes like Voyager (escape trajectory). Key Equations and Models Gravitational Force: \\[ F = \\frac{G M m}{r^2} \\] Equations of Motion (simplified 2D): \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} \\] Python Simulation (Code Overview) import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 # Earth mass r0 = 6.371e6 + 400000 # 400 km altitude v0 = 7700 # m/s x, y = r0, 0 vx, vy = 0, v0 dt = 1 trajectory = [] for _ in range(10000): r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt trajectory.append((x, y)) trajectory = np.array(trajectory) plt.plot(trajectory[:,0], trajectory[:,1]) plt.axis('equal') plt.show() Interactive Visualization const G = 6.67430e-11; const M = 5.972e24; const r0 = 6.371e6 + 4e5; function updateTrajectory() { const v0 = parseFloat(document.getElementById(\"velocitySelect\").value); let x = r0, y = 0; let vx = 0, vy = v0; const dt = 1; const steps = 1000; const X = [], Y = []; for (let i = 0; i < steps; i++) { const r = Math.sqrt(x*x + y*y); const ax = -G * M * x / Math.pow(r, 3); const ay = -G * M * y / Math.pow(r, 3); vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; X.push(x); Y.push(y); } Plotly.newPlot(\"trajectoryPlot\", [{ x: X, y: Y, mode: \"lines\", line: { color: \"green\" }, name: \"Trajectory\" }], { title: \"Simulated Payload Trajectory\", xaxis: { title: \"x (m)\" }, yaxis: { title: \"y (m)\" }, margin: { t: 50 } }); } window.onload = updateTrajectory; Conclusion Depending on its speed and release angle, the payload may fall back to Earth, enter stable orbit, or escape into space. Understanding this behavior is vital in launch vehicle design and planetary exploration. function toggleDarkMode() { document.body.classList.toggle(\"dark-mode\"); }","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Wave Interference Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u26a1 Lorentz Force Simulation body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f4f4f4; font-family: Arial, sans-serif; } .container { width: 95%; max-width: 960px; margin: 40px 0; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2 { color: #2c3e50; } .controls { margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; } label { font-weight: bold; } input[type=\"range\"] { width: 200px; } #plot { margin-top: 30px; } pre { background: #eee; padding: 10px; border-radius: 6px; overflow-x: auto; } \u26a1 Lorentz Force: Particle Motion in a Magnetic Field \ud83d\udcd8 What\u2019s Happening? When a charged particle moves through a magnetic field, it experiences a force perpendicular to its motion. This Lorentz Force causes the particle to follow circular or helical paths. The force is given by: F = q (v \u00d7 B) Charged particles spiral in a uniform magnetic field. The radius and direction of motion depend on the charge, velocity, and field strength. \u2699\ufe0f Simulation Controls Initial vx: 5 Initial vy: 0 Initial vz: 5 Magnetic field Bz: 1 function update() { let vx = parseFloat(document.getElementById(\"vx\").value); let vy = parseFloat(document.getElementById(\"vy\").value); let vz = parseFloat(document.getElementById(\"vz\").value); let Bz = parseFloat(document.getElementById(\"Bz\").value); document.getElementById(\"vxValue\").textContent = vx; document.getElementById(\"vyValue\").textContent = vy; document.getElementById(\"vzValue\").textContent = vz; document.getElementById(\"BzValue\").textContent = Bz; const q = 1.0; // charge const m = 1.0; // mass const dt = 0.01; const N = 2000; let x = [0], y = [0], z = [0]; let vx0 = vx, vy0 = vy, vz0 = vz; for (let i = 0; i < N; i++) { // Velocity update from Lorentz force (only magnetic field Bz) let ax = (q / m) * (vy0 * Bz); let ay = (q / m) * (-vx0 * Bz); let az = 0; vx0 += ax * dt; vy0 += ay * dt; vz0 += az * dt; // Position update x.push(x[i] + vx0 * dt); y.push(y[i] + vy0 * dt); z.push(z[i] + vz0 * dt); } Plotly.newPlot('plot', [{ type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { color: 'royalblue' }, name: 'Particle Path' }], { title: 'Trajectory of Charged Particle in Magnetic Field', scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { t: 30 } }); } update();","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory body { font-family: Arial, sans-serif; background: #f9f9f9; color: #222; margin: 20px; } h1, h2 { color: #003366; } section { background: #fff; padding: 20px; margin: 20px 0; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); } #network { height: 500px; border: 1px solid #ccc; margin-bottom: 20px; } pre { background: #eee; padding: 10px; border-radius: 5px; overflow-x: auto; } select, button { margin-top: 10px; margin-right: 10px; } Equivalent Resistance Using Graph Theory Overview Graph theory provides a powerful framework for modeling and analyzing complex electrical circuits. In traditional circuit analysis, determining the equivalent resistance between two points often requires manually reducing the circuit through a series of transformations. This becomes increasingly difficult as the circuit grows in size and complexity. By representing circuits as graphs\u2014where nodes are junctions and edges are resistors\u2014engineers and scientists can leverage algorithms to automate simplification and analysis. This approach not only streamlines the process but also enables new possibilities like symbolic computation, dynamic simulation, and integration into electronic design automation (EDA) tools. The page below introduces an interactive visual circuit editor built on these principles. It allows users to draw, manipulate, and analyze circuits while instantly computing resistances using basic parallel/series logic. This serves as an educational and prototypical tool for understanding and applying graph-theoretic techniques in circuit analysis. Interactive Circuit Editor Start Node: End Node: Compute Resistance Export as PNG Export as JSON Concept and Explanation In electrical circuits, calculating the total or \"equivalent\" resistance between two points is essential for understanding current flow and power distribution. Traditional methods involve step-by-step application of series and parallel rules. However, for more complex circuits\u2014especially ones with nested loops or multiple branches\u2014this approach becomes inefficient. Graph theory offers a powerful alternative. A circuit can be modeled as a graph, where nodes represent junctions and edges represent resistors. This abstraction allows us to apply algorithms for automatically simplifying and analyzing the network. Series connections are identified as nodes with two neighbors and merged into a single edge. Parallel connections are detected when multiple edges connect the same node pair, and can be reduced using the reciprocal sum formula for parallel resistances. Using these principles, this tool lets you: Create and edit circuit graphs interactively Visually assign resistance values between any two nodes Select start and end nodes to compute their combined resistance using direct or parallel connection logic Export your circuit as an image or downloadable JSON file for reuse This approach is not only more scalable but also opens the door to symbolic computation, live simulation, and integration with digital circuit design tools. const nodes = new vis.DataSet([ { id: 'A', label: 'A' }, { id: 'B', label: 'B' }, { id: 'C', label: 'C' }, { id: 'X', label: 'X' } ]); const edges = new vis.DataSet([ { from: 'A', to: 'X', label: '2', title: '2 \u03a9' }, { from: 'X', to: 'B', label: '3', title: '3 \u03a9' }, { from: 'A', to: 'B', label: '6', title: '6 \u03a9' }, { from: 'X', to: 'C', label: '4', title: '4 \u03a9' } ]); const container = document.getElementById('network'); const network = new vis.Network(container, { nodes, edges }, { manipulation: { enabled: true, addNode: function (data, callback) { const nodeId = prompt('Enter node ID:'); if (nodeId) { data.id = nodeId; data.label = nodeId; callback(data); populateSelectors(); } }, editNode: function (data, callback) { const newLabel = prompt('Edit node label:', data.label); if (newLabel !== null) { data.label = newLabel; callback(data); populateSelectors(); } } }, physics: false, edges: { font: { align: 'middle' } }, nodes: { shape: 'dot', size: 20, font: { size: 16, color: '#003366' }, borderWidth: 2 } }); function populateSelectors() { const nodeList = nodes.get(); const startSelect = document.getElementById('nodeStart'); const endSelect = document.getElementById('nodeEnd'); startSelect.innerHTML = ''; endSelect.innerHTML = ''; nodeList.forEach(node => { startSelect.add(new Option(node.label, node.id)); endSelect.add(new Option(node.label, node.id)); }); } function computeResistance() { const start = document.getElementById('nodeStart').value; const end = document.getElementById('nodeEnd').value; let total = 0; let count = 0; edges.get().forEach(edge => { if ((edge.from === start && edge.to === end) || (edge.from === end && edge.to === start)) { const r = parseFloat(edge.label); if (!isNaN(r)) { total += 1 / r; count++; } } }); const resultElement = document.getElementById('resistanceResult'); if (count > 0) { const result = 1 / total; resultElement.textContent = `Resistance from ${start} to ${end}: ${result.toFixed(2)} \u03a9`; } else { resultElement.textContent = `No direct connection between ${start} and ${end}`; } } function exportAsPNG() { html2canvas(document.getElementById('network')).then(canvas => { const link = document.createElement('a'); link.download = 'circuit.png'; link.href = canvas.toDataURL(); link.click(); }); } function exportAsJSON() { const content = { nodes: nodes.get(), edges: edges.get() }; const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(content, null, 2)); const a = document.createElement('a'); a.setAttribute('href', dataStr); a.setAttribute('download', 'circuit.json'); document.body.appendChild(a); a.click(); document.body.removeChild(a); } window.addEventListener('load', populateSelectors);","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Central Limit Theorem Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; display: flex; justify-content: center; align-items: center; padding: 40px; } .container { background-color: #ffffff; padding: 30px; border-radius: 10px; box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1000px; } h1, h2 { color: #2c3e50; margin-bottom: 10px; } p { margin-bottom: 15px; line-height: 1.6; } select, input { margin-right: 10px; padding: 6px 12px; border-radius: 5px; border: 1px solid #ccc; } button { background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; } canvas { max-width: 100%; margin-top: 30px; } \ud83d\udcca Exploring the Central Limit Theorem Welcome! This interactive tool is designed to help you understand one of the most important ideas in statistics \u2014 the Central Limit Theorem (CLT). The CLT explains why many distributions in the real world tend to be normal (bell-shaped) when we average things out. Whether we are measuring manufacturing defects, average scores, or experimental results, the mean of those measurements will often look normal \u2014 even if the original data does not. Use the options below to select a population distribution and simulate the process of sampling from it. You\u2019ll observe how the sample means begin to form a normal distribution as you increase the sample size. \ud83c\udfaf Choose Distribution and Parameters Population Type: Uniform Exponential Binomial Sample Size: Samples Count: Run Simulation \ud83e\udde0 Why This Matters This interactive visualization shows how sample means form a normal distribution even when starting from highly skewed or discrete populations. The CLT underpins confidence intervals, hypothesis testing, and is vital in statistical modeling. function generatePopulation(dist, size) { const data = []; if (dist === 'uniform') { for (let i = 0; i < size; i++) data.push(Math.random()); } else if (dist === 'exponential') { for (let i = 0; i < size; i++) data.push(-Math.log(1 - Math.random())); } else if (dist === 'binomial') { for (let i = 0; i < size; i++) { let sum = 0; for (let j = 0; j < 10; j++) sum += Math.random() < 0.5 ? 1 : 0; data.push(sum); } } return data; } function simulate() { const distribution = document.getElementById('distribution').value; const sampleSize = parseInt(document.getElementById('sampleSize').value); const samples = parseInt(document.getElementById('samples').value); const means = []; for (let i = 0; i < samples; i++) { const pop = generatePopulation(distribution, sampleSize); const mean = pop.reduce((a, b) => a + b, 0) / sampleSize; means.push(mean); } const ctx = document.getElementById('histogram').getContext('2d'); if (window.histChart) window.histChart.destroy(); const bins = 40; const min = Math.min(...means); const max = Math.max(...means); const step = (max - min) / bins; const labels = Array.from({ length: bins }, (_, i) => (min + i * step).toFixed(2)); const frequencies = Array(bins).fill(0); means.forEach(m => { const index = Math.min(Math.floor((m - min) / step), bins - 1); frequencies[index]++; }); window.histChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Sample Means', data: frequencies, backgroundColor: 'rgba(52, 152, 219, 0.5)', borderColor: 'rgba(41, 128, 185, 1)', borderWidth: 1 }] }, options: { scales: { x: { title: { display: true, text: 'Sample Mean' } }, y: { title: { display: true, text: 'Frequency' } } }, plugins: { title: { display: true, text: `Sampling Distribution of the Mean (${distribution})` } } } }); const avg = (means.reduce((a, b) => a + b, 0) / samples).toFixed(3); const variance = (means.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples).toFixed(3); document.getElementById('summary').innerText = `Average of sample means: ${avg}, Variance: ${variance}`; }","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Estimating \u03c0 Using Monte Carlo Methods body { font-family: Arial, sans-serif; background: #f8f8f8; padding: 20px; color: #222; } h1, h2, h3 { color: #003366; } canvas { border: 1px solid #ccc; margin: 10px 0; } section { margin-bottom: 40px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.05); } .controls { margin-top: 10px; } label { margin-right: 10px; } Estimating \u03c0 Using Monte Carlo Methods Overview \u03c0 is a fundamental constant in mathematics, representing the ratio of a circle's circumference to its diameter. While its value is well known, one fascinating way to approximate \u03c0 is through Monte Carlo simulation \u2014 using randomness to solve a deterministic problem. This approach leverages the law of large numbers : by running many random experiments, we can statistically converge to the true value of \u03c0. Two classic methods are featured in this simulator: \ud83c\udfaf 1. Circle-Based Point Sampling This method inscribes a unit circle within a square. Random points are scattered across the square, and the ratio of points that fall inside the circle estimates the area \u2014 and therefore \u03c0: \\[\\pi \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}}\\] \ud83d\udccf 2. Buffon\u2019s Needle Experiment Proposed by Georges-Louis Leclerc, Comte de Buffon in the 18th century, this probabilistic method involves dropping a needle of length \\(L\\) onto a floor with evenly spaced parallel lines \\(d\\) apart. The chance of a needle crossing a line is tied directly to \u03c0: \\[\\pi \\approx \\frac{2 \\cdot L \\cdot N}{d \\cdot C}\\] \ud83d\udd0d Why It Matters Monte Carlo methods aren\u2019t just for estimating \u03c0 \u2014 they\u2019re foundational in physics, finance, machine learning, and beyond. These simulations illustrate how randomness can reveal structure, and how simple visual models can produce profound results. 1. Circle-Based Simulation Number of Points: 1000 Simulate Estimated \u03c0: \u2014 2. Buffon's Needle Simulation Number of Throws: 1000 Needle Length \\( L = \\) Line Spacing \\( d = \\) Simulate Estimated \u03c0: \u2014 // Circle simulation const circleCanvas = document.getElementById(\"circleCanvas\"); const ctx1 = circleCanvas.getContext(\"2d\"); document.getElementById(\"circlePoints\").oninput = function () { document.getElementById(\"circleCount\").textContent = this.value; }; function simulateCircle() { const points = +document.getElementById(\"circlePoints\").value; let inside = 0; ctx1.clearRect(0, 0, 400, 400); ctx1.beginPath(); ctx1.arc(200, 200, 200, 0, 2 * Math.PI); ctx1.stroke(); for (let i = 0; i < points; i++) { const x = Math.random(); const y = Math.random(); const dx = x - 0.5, dy = y - 0.5; const d2 = dx * dx + dy * dy; const cx = x * 400, cy = y * 400; ctx1.fillStyle = d2 <= 0.25 ? \"blue\" : \"red\"; if (d2 <= 0.25) inside++; ctx1.fillRect(cx, cy, 1.5, 1.5); } const pi = 4 * inside / points; document.getElementById(\"circleResult\").innerHTML = `<strong>Estimated \u03c0: ${pi.toFixed(5)}</strong>`; } // Buffon's Needle simulation const needleCanvas = document.getElementById(\"needleCanvas\"); const ctx2 = needleCanvas.getContext(\"2d\"); document.getElementById(\"needleThrows\").oninput = function () { document.getElementById(\"needleCount\").textContent = this.value; }; function simulateNeedle() { const throws = +document.getElementById(\"needleThrows\").value; const L = +document.getElementById(\"needleLength\").value; const d = +document.getElementById(\"lineSpacing\").value; let crosses = 0; ctx2.clearRect(0, 0, 400, 400); ctx2.strokeStyle = \"#999\"; for (let x = d; x < 400; x += d) { ctx2.beginPath(); ctx2.moveTo(x, 0); ctx2.lineTo(x, 400); ctx2.stroke(); } ctx2.strokeStyle = \"#000\"; for (let i = 0; i < throws; i++) { const x = Math.random() * 400; const y = Math.random() * 400; const angle = Math.random() * Math.PI; const x2 = x + (L / 2) * Math.cos(angle); const x1 = x - (L / 2) * Math.cos(angle); const y2 = y + (L / 2) * Math.sin(angle); const y1 = y - (L / 2) * Math.sin(angle); ctx2.beginPath(); ctx2.moveTo(x1, y1); ctx2.lineTo(x2, y2); ctx2.stroke(); const xMin = Math.min(x1, x2); const xMax = Math.max(x1, x2); for (let lineX = d; lineX < 400; lineX += d) { if (xMin < lineX && xMax > lineX) { crosses++; break; } } } let pi = '\u2014'; if (crosses > 0) { pi = (2 * L * throws) / (d * crosses); pi = pi.toFixed(5); } document.getElementById(\"needleResult\").innerHTML = `<strong>Estimated \u03c0: ${pi} (${crosses} crossings)</strong>`; } simulateCircle(); simulateNeedle();","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}