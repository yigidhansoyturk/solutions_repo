{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: Range vs Angle body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 1000px; padding: 0 20px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } input[type=\"range\"], input[type=\"number\"] { width: 200px; margin-right: 10px; } #controls label { font-weight: bold; margin-right: 10px; } #plot { margin-top: 20px; } pre { background: #f4f4f4; padding: 10px; overflow-x: auto; } ul { margin-top: 0; } /* Style for formulas to keep the size consistent */ .formula { font-size: 1.5em; font-family: 'Times New Roman', Times, serif; font-weight: bold; text-align: center; margin: 20px 0; color: #e74c3c; } /* Small formulas for inline usage */ .small-formula { font-size: 1.2em; font-family: 'Times New Roman', Times, serif; font-weight: normal; text-align: center; margin: 10px 0; color: #333; } \ud83d\ude80 Investigating Range vs Angle in Projectile Motion A projectile launched at an angle \u03b8 and initial speed v\u2080 follows a parabolic path under gravity. Assuming flat terrain and no air resistance, the horizontal range is given by the equation: \\( R = \\frac{{v_0^2 \\cdot \\sin(2\\theta)}}{g} \\) This is derived from the motion's horizontal and vertical components: \\( v_x = v_0 \\cdot \\cos(\\theta) \\) (horizontal component) \\( v_y = v_0 \\cdot \\sin(\\theta) \\) (vertical component) \\( \\text{Time of flight} = \\frac{2 \\cdot v_y}{g} \\) \\( \\text{Range} = v_x \\cdot \\text{time} \\) At an ideal launch angle of 45\u00b0, the range reaches its maximum value. We will explore how the range varies with different angles and initial velocities. \ud83e\uddea Simulation Controls Initial Velocity (v\u2080): 30 m/s Gravity (g): m/s\u00b2 Launch Height (h\u2080): meters \ud83d\udcca Graph Interpretation The plot shows how the horizontal range varies with angle for a given set of conditions. When height is zero, the range is maximized at 45\u00b0. If you increase height, this symmetry is broken. Higher velocities stretch the curve upwards. \ud83c\udf0d Real-World Considerations The model assumes: Flat launch/landing height No air resistance Still air and no spin In real scenarios, these factors matter: Air drag: slows the projectile and reduces range Launch height: longer flight time, increases range Wind: adds or subtracts from velocity Magnus effect: from spin, curves the path These effects require more complex models, typically solved numerically or via simulations. // Function to compute range based on initial velocity, gravity, launch angle, and height function computeRange(v0, g, angleDeg, h0) { const theta = angleDeg * Math.PI / 180; // Convert angle to radians const v0x = v0 * Math.cos(theta); // Horizontal velocity const v0y = v0 * Math.sin(theta); // Vertical velocity // Time of flight with height: solve the quadratic equation for time const t_flight = (v0y + Math.sqrt(v0y * v0y + 2 * g * h0)) / g; return v0x * t_flight; // Range = horizontal velocity * time of flight } // Function to update the plot based on user input function updateAll() { const v0 = parseFloat(document.getElementById('v0').value); // Get velocity from input const g = parseFloat(document.getElementById('gravity').value); // Get gravity from input const h0 = parseFloat(document.getElementById('height').value); // Get height from input document.getElementById('v0Val').textContent = v0; // Update displayed value of v\u2080 const angles = []; // Array for angles const ranges = []; // Array for corresponding ranges // Calculate the range for angles from 0\u00b0 to 90\u00b0 (in increments of 0.5\u00b0) for (let theta = 0; theta <= 90; theta += 0.5) { angles.push(theta); ranges.push(computeRange(v0, g, theta, h0)); } // Plot the range vs angle const trace = { x: angles, y: ranges, type: 'scatter', mode: 'lines', line: { color: 'royalblue', width: 3 }, name: `v\u2080 = ${v0} m/s` }; // Plot layout const layout = { title: 'Range vs Angle of Projection', xaxis: { title: 'Angle (degrees)' }, yaxis: { title: 'Range (meters)' } }; Plotly.newPlot('plot', [trace], layout); // Plot using Plotly } // Initialize the plot with default values updateAll();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Simulator body { font-family: Arial, sans-serif; margin: 0 auto; max-width: 1000px; padding: 20px; background-color: #fefefe; color: #333; line-height: 1.6; overflow-x: hidden; /* Sayfa kaymas\u0131n\u0131 engellemek i\u00e7in */ } h1, h2, h3 { color: #2c3e50; } .controls input { margin: 5px 10px; } .scenario-btn { margin: 15px 5px; padding: 8px 15px; cursor: pointer; background-color: #f0f0f0; border: 1px solid #ccc; font-size: 14px; } #plot { margin-top: 30px; } code { background: #f4f4f4; padding: 3px 6px; border-radius: 4px; } h2 { font-size: 1.4em; /* Ba\u015fl\u0131k boyutunu k\u00fc\u00e7\u00fcltme */ } .scenario-btn { font-size: 16px; } \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 Theoretical Foundation The forced damped pendulum is governed by the nonlinear second-order differential equation: \\( \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\) Here: \\( \\theta \\) : Angular displacement \\( b \\) : Damping coefficient \\( L \\) : Length of pendulum \\( A \\) : Driving amplitude \\( \\omega \\) : Driving angular frequency This system can exhibit a wide variety of behaviors: from simple oscillations to chaotic motion. \ud83c\udf9b Simulation Controls Damping (b): Amplitude (A): Omega (\u03c9): Length (L): \u03b8\u2080: \u03b8\u0307\u2080: Run Simulation \ud83d\udca1 Example Scenarios: Periodic (b=0.2, A=1.2, \u03c9=2.0) Resonance (b=0.05, A=0.9, \u03c9\u2248\u221a(g/L)) Chaotic (b=0.1, A=1.5, \u03b8\u2080=1.5) \ud83d\udcca What You See on the Graph The plot below shows the angular displacement \\( \\theta(t) \\) over time, based on the chosen parameters. By changing the damping, driving amplitude, and frequency, you can observe transitions between regular and chaotic motion. function pendulumODE(t, state, b, g, L, A, omega) { const [theta, v] = state; return [v, -b * v - (g / L) * Math.sin(theta) + A * Math.cos(omega * t)]; } function rungeKutta(f, y0, t0, dt, steps, params) { let t = t0; let y = y0; const result = [[t, ...y]]; for (let i = 0; i < steps; i++) { const k1 = f(t, y, ...params); const k2 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k1[j]), ...params); const k3 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k2[j]), ...params); const k4 = f(t + dt, y.map((yi, j) => yi + dt * k3[j]), ...params); y = y.map((yi, j) => yi + dt / 6 * (k1[j] + 2*k2[j] + 2*k3[j] + k4[j])); t += dt; result.push([t, ...y]); } return result; } function runSimulation() { const b = parseFloat(document.getElementById('b').value); const A = parseFloat(document.getElementById('A').value); const omega = parseFloat(document.getElementById('omega').value); const L = parseFloat(document.getElementById('L').value); const theta0 = parseFloat(document.getElementById('theta0').value); const v0 = parseFloat(document.getElementById('v0').value); const data = rungeKutta(pendulumODE, [theta0, v0], 0, 0.05, 1000, [b, 9.81, L, A, omega]); const t = data.map(d => d[0]); const theta = data.map(d => d[1]); Plotly.newPlot('plot', [{ x: t, y: theta, type: 'scatter', mode: 'lines', line: { color: 'blue' } }], { title: 'Angular Displacement Over Time', xaxis: { title: 'Time (s)' }, yaxis: { title: '\u03b8 (rad)' } }); } function loadScenario(type) { if (type === 'periodic') { document.getElementById('b').value = 0.2; document.getElementById('A').value = 1.2; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"This example shows periodic behavior with light damping and moderate forcing. The pendulum synchronizes with the driving force.\"; } else if (type === 'resonance') { document.getElementById('b').value = 0.05; document.getElementById('A').value = 0.9; document.getElementById('omega').value = 3.13; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"Here the driving frequency matches the system's natural frequency, causing resonance and increasing amplitude dramatically.\"; } else if (type === 'chaotic') { document.getElementById('b').value = 0.1; document.getElementById('A').value = 1.5; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 1.5; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"With strong forcing and large initial angle, the motion becomes chaotic. Even tiny changes lead to very different outcomes.\"; } runSimulation(); } runSimulation();","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Kepler's Third Law - Circular Orbits body { font-family: Arial, sans-serif; background-color: #f4f4f9; margin: 0; padding: 0; } header { background-color: #78B22F; color: white; padding: 20px; text-align: center; } .container { padding: 30px; margin: 0 auto; max-width: 1200px; } h2 { color: #333; } p { font-size: 18px; color: #555; line-height: 1.6; } .graph { text-align: center; margin-top: 40px; } .graph img { max-width: 80%; border: 2px solid #333; border-radius: 10px; } .section { margin-bottom: 40px; } footer { text-align: center; padding: 20px; background-color: #78B22F; color: white; margin-top: 40px; } Kepler's Third Law and Circular Orbits What is Kepler's Third Law? Kepler's Third Law describes the relationship between the orbital period and the orbital radius of celestial bodies like planets and satellites. It states that the square of the orbital period (T) is proportional to the cube of the orbital radius (r), specifically: T 2 \u221d r 3 . This means that the farther a planet is from the sun, the longer it takes to complete an orbit. Understanding the Relationship This law is crucial for understanding planetary motion and gravitational interactions. The relationship can be derived from Newton's Law of Universal Gravitation and centripetal force. In simpler terms, the force that keeps planets in orbit is the same force that makes them move in circular paths. The orbital period increases as the orbital radius increases, and this simple relationship helps scientists calculate the distances of planets from stars. Graphical Representation of Kepler's Third Law Below is a graphical representation showing how the square of the orbital period (T 2 ) relates to the cube of the orbital radius (r 3 ) for circular orbits. Real-World Examples: Orbital Periods This relationship applies to many celestial bodies, including our Moon orbiting Earth and the planets in our Solar System. For example, the Earth takes approximately 365 days to orbit the Sun, while the Moon takes about 27.3 days to orbit Earth. This concept also allows scientists to calculate the mass of a planet by examining the orbits of satellites around it. Elliptical Orbits and Kepler's Law Kepler's Third Law also applies to elliptical orbits, where the semi-major axis replaces the orbital radius. While circular orbits are the simplest case, many celestial bodies follow elliptical paths, and the law still holds as long as we use the semi-major axis instead of the radius. Created as a part of learning Kepler's Laws and Orbital Mechanics","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 1000px; padding: 0 20px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } input[type=\"range\"], input[type=\"number\"] { width: 200px; margin-right: 10px; } #controls label { font-weight: bold; margin-right: 10px; } #plot { margin-top: 20px; } pre { background: #f4f4f4; padding: 10px; overflow-x: auto; } ul { margin-top: 0; } /* Style for formulas to keep the size consistent */ .formula { font-size: 1.5em; font-family: 'Times New Roman', Times, serif; font-weight: bold; text-align: center; margin: 20px 0; color: #e74c3c; } /* Small formulas for inline usage */ .small-formula { font-size: 1.2em; font-family: 'Times New Roman', Times, serif; font-weight: normal; text-align: center; margin: 10px 0; color: #333; } \ud83d\ude80 Escape Velocities and Cosmic Velocities \ud83d\udcd8 Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. \ud83e\uddd1\u200d\ud83c\udfeb First, Second, and Third Cosmic Velocities The first, second, and third cosmic velocities describe different escape velocities for a body to enter orbit, escape from a celestial body, or escape a star system: First Cosmic Velocity (\\(v_1\\)): The velocity required to enter a circular orbit around the celestial body. Second Cosmic Velocity (\\(v_2\\)): The velocity required to escape the celestial body's gravitational pull (escape velocity). Third Cosmic Velocity (\\(v_3\\)): The velocity required to escape the gravitational influence of a star system (e.g., the Sun's gravitational pull from Earth). Formulas \\( v_1 = \\sqrt{\\frac{GM}{R}} \\) The first cosmic velocity is derived from the requirement for an object to enter a stable orbit around a planet. Here: \\( G \\) is the gravitational constant \\( M \\) is the mass of the celestial body \\( R \\) is the radius of the celestial body \\( v_2 = \\sqrt{\\frac{2GM}{R}} \\) The second cosmic velocity is the escape velocity, which is derived from the condition that the kinetic energy must overcome the gravitational potential energy of the object. \\( v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{R_{\\text{earth}}}} \\) The third cosmic velocity describes the escape speed needed to leave the solar system, derived from the Sun's mass and the Earth's distance from the Sun. \ud83e\uddea Calculation of Velocities for Different Celestial Bodies Let's calculate the first, second, and third cosmic velocities for different celestial bodies like Earth, Mars, and Jupiter. Mass of Earth: \\( M_{\\text{earth}} = 5.972 \\times 10^{24} \\, \\text{kg} \\) Mass of Mars: \\( M_{\\text{mars}} = 6.4171 \\times 10^{23} \\, \\text{kg} \\) Mass of Jupiter: \\( M_{\\text{jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg} \\) Radius of Earth: \\( R_{\\text{earth}} = 6.371 \\times 10^6 \\, \\text{m} \\) Radius of Mars: \\( R_{\\text{mars}} = 3.396 \\times 10^6 \\, \\text{m} \\) Radius of Jupiter: \\( R_{\\text{jupiter}} = 6.991 \\times 10^7 \\, \\text{m} \\) Distance from Earth to Sun: \\( R_{\\text{earth-sun}} = 1.496 \\times 10^{11} \\, \\text{m} \\) Using these values, the first, second, and third cosmic velocities can be calculated for each body. Graphical Representation of Cosmic Velocities Below is a plot representing the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. \ud83d\udcca Graph Interpretation The plot shows how the cosmic velocities change with respect to the size and mass of the celestial body. The first cosmic velocity (orbital velocity) is the smallest, followed by the second cosmic velocity (escape velocity). The third cosmic velocity, which is the largest, represents the velocity needed to escape the solar system. \ud83c\udf0d Real-World Applications Understanding these velocities is vital for space exploration. The first cosmic velocity is essential for satellite launches, while the second cosmic velocity is crucial for interplanetary missions. The third cosmic velocity is needed when considering travel beyond the solar system, such as interstellar exploration. // This is a placeholder for the actual Plotly chart generation // You can add the necessary calculations and visualization code here.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83c\udf0a Wave Interference Simulation * { box-sizing: border-box; } body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f9f9f9; font-family: Arial, sans-serif; color: #333; } .container { margin: 40px 0; width: 95%; max-width: 960px; padding: 20px; background-color: #fff; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px 20px 0; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; border-radius: 6px; } .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-top: 10px; } .controls label { margin-right: 6px; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Wave Interference Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u26a1 Lorentz Force Simulation body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f4f4f4; font-family: Arial, sans-serif; } .container { width: 95%; max-width: 960px; margin: 40px 0; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2 { color: #2c3e50; } .controls { margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; } label { font-weight: bold; } input[type=\"range\"] { width: 200px; } #plot { margin-top: 30px; } pre { background: #eee; padding: 10px; border-radius: 6px; overflow-x: auto; } \u26a1 Lorentz Force: Particle Motion in a Magnetic Field \ud83d\udcd8 What\u2019s Happening? When a charged particle moves through a magnetic field, it experiences a force perpendicular to its motion. This Lorentz Force causes the particle to follow circular or helical paths. The force is given by: F = q (v \u00d7 B) Charged particles spiral in a uniform magnetic field. The radius and direction of motion depend on the charge, velocity, and field strength. \u2699\ufe0f Simulation Controls Initial vx: 5 Initial vy: 0 Initial vz: 5 Magnetic field Bz: 1 function update() { let vx = parseFloat(document.getElementById(\"vx\").value); let vy = parseFloat(document.getElementById(\"vy\").value); let vz = parseFloat(document.getElementById(\"vz\").value); let Bz = parseFloat(document.getElementById(\"Bz\").value); document.getElementById(\"vxValue\").textContent = vx; document.getElementById(\"vyValue\").textContent = vy; document.getElementById(\"vzValue\").textContent = vz; document.getElementById(\"BzValue\").textContent = Bz; const q = 1.0; // charge const m = 1.0; // mass const dt = 0.01; const N = 2000; let x = [0], y = [0], z = [0]; let vx0 = vx, vy0 = vy, vz0 = vz; for (let i = 0; i < N; i++) { // Velocity update from Lorentz force (only magnetic field Bz) let ax = (q / m) * (vy0 * Bz); let ay = (q / m) * (-vx0 * Bz); let az = 0; vx0 += ax * dt; vy0 += ay * dt; vz0 += az * dt; // Position update x.push(x[i] + vx0 * dt); y.push(y[i] + vy0 * dt); z.push(z[i] + vz0 * dt); } Plotly.newPlot('plot', [{ type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { color: 'royalblue' }, name: 'Particle Path' }], { title: 'Trajectory of Charged Particle in Magnetic Field', scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { t: 30 } }); } update();","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udcd0 Equivalent Resistance Using Graph Theory body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #f7f9fa; min-height: 100vh; } .container { max-width: 960px; background: white; padding: 40px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); border-radius: 10px; } h1, h2, h3 { color: #2c3e50; } #result { font-weight: bold; color: #1e8449; } button { margin-top: 10px; padding: 10px 20px; background: #3498db; border: none; color: white; border-radius: 5px; cursor: pointer; } #circuitGraph { margin-top: 30px; } \ud83d\udcd0 Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Calculating equivalent resistance is crucial in understanding how electrical circuits behave. Traditional methods using only series and parallel resistor rules can become challenging with complex networks. Graph theory offers a structured, algorithmic approach. In graph theory, we treat each junction as a node and each resistor as an edge with a weight (resistance). By merging resistors using logical rules based on connectivity, we simplify the network into a single equivalent resistance efficiently. \ud83d\udee0\ufe0f How It Works Draw the circuit as a graph using nodes and resistors (edges with weights). Combine resistors in series\u2014when there's a single path between two junctions. Combine resistors in parallel\u2014when multiple resistors connect the same two junctions. Repeat the simplification process until one edge remains representing total resistance. \ud83e\uddea Try It Out (Simple Series & Parallel Example) This example shows a basic circuit with three resistors: Resistor 1: Node A \u2192 B (100 \u03a9) Resistor 2: Node B \u2192 C (200 \u03a9) Resistor 3: Node A \u2192 C (300 \u03a9, in parallel with the A\u2192B\u2192C path) We will compute the total resistance from Node A to Node C using both paths (series and parallel). \ud83d\udca1 Compute Equivalent Resistance \ud83d\udcca Efficiency & Improvements Optimized for acyclic graphs and can handle simple cycles. Further optimized using union-find, DFS, or matrix-based solvers. Adaptable to large-scale simulations using network analysis libraries. \ud83d\udcda Examples & Tests \ud83d\udd38 Series: A-B (100\u03a9), B-C (200\u03a9) \u2192 R_eq = 300\u03a9 \ud83d\udd38 Parallel: A-C (300\u03a9) in parallel with A-B-C path (100\u03a9 + 200\u03a9) \u2192 R_eq = 150\u03a9 function calculateResistance() { const R1 = 100; const R2 = 200; const R3 = 300; const seriesPath = R1 + R2; const parallel = 1 / (1 / R3 + 1 / seriesPath); document.getElementById(\"result\").innerText = `Total Equivalent Resistance: ${parallel.toFixed(2)} \u03a9`; } const nodes = [ { id: 'A', x: 0, y: 1 }, { id: 'B', x: 1, y: 1 }, { id: 'C', x: 2, y: 0.5 }, ]; const edges = [ { from: 'A', to: 'B', value: 100 }, { from: 'B', to: 'C', value: 200 }, { from: 'A', to: 'C', value: 300 }, ]; const edgeTraces = edges.map(edge => { const fromNode = nodes.find(n => n.id === edge.from); const toNode = nodes.find(n => n.id === edge.to); return { type: 'scatter', x: [fromNode.x, toNode.x], y: [fromNode.y, toNode.y], mode: 'lines+text', line: { width: 2 }, text: [`${edge.value}\u03a9`], textposition: 'top center', hoverinfo: 'none', showlegend: false }; }); const nodeTrace = { type: 'scatter', mode: 'markers+text', x: nodes.map(n => n.x), y: nodes.map(n => n.y), marker: { size: 16, color: '#2980b9' }, text: nodes.map(n => n.id), textposition: 'bottom center', hoverinfo: 'text' }; const layout = { title: 'Resistor Network Visualization', margin: { t: 50 }, xaxis: { visible: false }, yaxis: { visible: false }, height: 400 }; Plotly.newPlot('circuitGraph', [...edgeTraces, nodeTrace], layout);","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Central Limit Theorem Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; display: flex; justify-content: center; align-items: center; padding: 40px; } .container { background-color: #ffffff; padding: 30px; border-radius: 10px; box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1000px; } h1, h2 { color: #2c3e50; margin-bottom: 10px; } p { margin-bottom: 15px; line-height: 1.6; } select, input { margin-right: 10px; padding: 6px 12px; border-radius: 5px; border: 1px solid #ccc; } button { background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; } canvas { max-width: 100%; margin-top: 30px; } \ud83d\udcca Exploring the Central Limit Theorem Welcome! This interactive tool is designed to help you understand one of the most important ideas in statistics \u2014 the Central Limit Theorem (CLT). The CLT explains why many distributions in the real world tend to be normal (bell-shaped) when we average things out. Whether we are measuring manufacturing defects, average scores, or experimental results, the mean of those measurements will often look normal \u2014 even if the original data does not. Use the options below to select a population distribution and simulate the process of sampling from it. You\u2019ll observe how the sample means begin to form a normal distribution as you increase the sample size. \ud83c\udfaf Choose Distribution and Parameters Population Type: Uniform Exponential Binomial Sample Size: Samples Count: Run Simulation \ud83e\udde0 Why This Matters This interactive visualization shows how sample means form a normal distribution even when starting from highly skewed or discrete populations. The CLT underpins confidence intervals, hypothesis testing, and is vital in statistical modeling. function generatePopulation(dist, size) { const data = []; if (dist === 'uniform') { for (let i = 0; i < size; i++) data.push(Math.random()); } else if (dist === 'exponential') { for (let i = 0; i < size; i++) data.push(-Math.log(1 - Math.random())); } else if (dist === 'binomial') { for (let i = 0; i < size; i++) { let sum = 0; for (let j = 0; j < 10; j++) sum += Math.random() < 0.5 ? 1 : 0; data.push(sum); } } return data; } function simulate() { const distribution = document.getElementById('distribution').value; const sampleSize = parseInt(document.getElementById('sampleSize').value); const samples = parseInt(document.getElementById('samples').value); const means = []; for (let i = 0; i < samples; i++) { const pop = generatePopulation(distribution, sampleSize); const mean = pop.reduce((a, b) => a + b, 0) / sampleSize; means.push(mean); } const ctx = document.getElementById('histogram').getContext('2d'); if (window.histChart) window.histChart.destroy(); const bins = 40; const min = Math.min(...means); const max = Math.max(...means); const step = (max - min) / bins; const labels = Array.from({ length: bins }, (_, i) => (min + i * step).toFixed(2)); const frequencies = Array(bins).fill(0); means.forEach(m => { const index = Math.min(Math.floor((m - min) / step), bins - 1); frequencies[index]++; }); window.histChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Sample Means', data: frequencies, backgroundColor: 'rgba(52, 152, 219, 0.5)', borderColor: 'rgba(41, 128, 185, 1)', borderWidth: 1 }] }, options: { scales: { x: { title: { display: true, text: 'Sample Mean' } }, y: { title: { display: true, text: 'Frequency' } } }, plugins: { title: { display: true, text: `Sampling Distribution of the Mean (${distribution})` } } } }); const avg = (means.reduce((a, b) => a + b, 0) / samples).toFixed(3); const variance = (means.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples).toFixed(3); document.getElementById('summary').innerText = `Average of sample means: ${avg}, Variance: ${variance}`; }","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}