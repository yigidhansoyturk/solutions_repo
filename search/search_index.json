{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: Range vs Angle body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 900px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } pre { background-color: #f0f0f0; padding: 10px; overflow-x: auto; } code { font-family: Consolas, monospace; color: #2d3436; } #plot { margin-top: 20px; } label { font-weight: bold; } Investigating the Range as a Function of the Angle of Projection \ud83d\udcd8 Theoretical Foundation In ideal projectile motion, an object launched at angle \u03b8 with speed v\u2080 follows a parabolic path. The horizontal range R is derived from Newton\u2019s laws as: R = (v\u2080\u00b2 * sin(2\u03b8)) / g This equation emerges by solving the motion components: vx = v\u2080 * cos(\u03b8) vy = v\u2080 * sin(\u03b8) Time of flight: T = 2 * v\u2080 * sin(\u03b8) / g Range: R = vx * T This results in a family of parabolas based on initial velocity and angle. All trajectories share a common shape but scale differently with v\u2080 and \u03b8 . \ud83e\uddea Simulation: Range vs Angle Adjust Initial Velocity (m/s): 30 m/s \ud83d\udcc8 Graphical Representations The graph above shows how the range changes with projection angle. Maximum range is achieved at 45\u00b0 when launched from flat ground. You can observe how higher initial velocities scale the range. \ud83e\udde0 Limitations and Real-World Factors This ideal model assumes: No air resistance Flat launch and landing heights No wind or drag Realistic modeling can include: Drag force (air resistance) Uneven terrain or launch height Wind vectors Spinning effects (like Magnus force) These can be simulated using numerical methods like Euler or Runge-Kutta solvers. \ud83d\udcdc Python Code (for reference or notebook submission) You can copy this into a Python file or Jupyter Notebook. import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angle_deg): angle_rad = np.radians(angle_deg) return (v0**2 * np.sin(2 * angle_rad)) / g v0 = 30.0 g = 9.81 angles = np.linspace(0, 90, 500) ranges = compute_range(v0, g, angles) plt.plot(angles, ranges) plt.title(\\\"Range vs Angle of Projection\\\") plt.xlabel(\\\"Angle (degrees)\\\") plt.ylabel(\\\"Range (meters)\\\") plt.grid(True) plt.show() function computeRange(v0, g, angleDeg) { const angleRad = angleDeg * Math.PI / 180; return (Math.pow(v0, 2) * Math.sin(2 * angleRad)) / g; } function updatePlot() { const g = 9.81; const v0 = parseFloat(document.getElementById('velocity').value); document.getElementById('velocityValue').textContent = v0; const angles = []; const ranges = []; for (let theta = 0; theta <= 90; theta += 0.5) { angles.push(theta); ranges.push(computeRange(v0, g, theta)); } const trace = { x: angles, y: ranges, type: 'scatter', mode: 'lines', line: { color: 'royalblue' }, name: `v\u2080 = ${v0} m/s` }; const layout = { title: 'Range vs Angle of Projection', xaxis: { title: 'Angle (degrees)' }, yaxis: { title: 'Range (meters)' } }; Plotly.newPlot('plot', [trace], layout); } updatePlot(); // initial render","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background: linear-gradient(to right, #eef2f7, #d9e2ec); color: #2d3748; } .container { max-width: 960px; margin: 40px auto; padding: 40px; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); } h1 { font-size: 3rem; color: #1a202c; text-align: center; margin-bottom: 1rem; } h2 { font-size: 2rem; margin-top: 2rem; color: #2b6cb0; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.3rem; } p, ul { font-size: 1.125rem; line-height: 1.75; } ul { margin-left: 1.5rem; } pre { background-color: #2d3748; color: #f7fafc; padding: 20px; border-radius: 10px; overflow-x: auto; font-size: 0.95rem; } code { font-family: 'Courier New', monospace; } footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #718096; } Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. By varying the parameters of the external force\u2014amplitude and frequency\u2014a diverse class of solutions can be observed, highlighting synchronized oscillations, chaotic motion, and resonance phenomena. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: d\u00b2\u03b8/dt\u00b2 + b*d\u03b8/dt + \u03c9\u2080\u00b2*sin(\u03b8) = A*cos(\u03c9*t) b : damping coefficient \u03c9\u2080 : natural angular frequency A : amplitude of the external periodic force \u03c9 : driving frequency For small angles, sin(\u03b8) \u2248 \u03b8 , leading to a linearized form suitable for analytical solutions. However, full dynamics require numerical exploration due to nonlinearity and external forcing. Analysis of Dynamics Effect of damping coefficient, driving amplitude, and frequency on the pendulum's behavior Transition between regular oscillations and chaotic motion Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, b, omega0, A, omega): theta, omega_ = y dydt = [omega_, -b * omega_ - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt b = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 t_span = [0, 40] t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(pendulum, t_span, [0.1, 0], args=(b, omega0, A, omega), t_eval=t_eval) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() Practical Applications Energy harvesting in mechanical and piezoelectric systems Bridge and building resonance analysis Driven RLC circuits in electronics Limitations and Extensions Limitations: Linear damping approximation Sinusoidal driving force only Does not account for external noise or stochastic effects Possible Extensions: Nonlinear damping (e.g., quadratic or Coulomb friction) Non-periodic or real-world data-driven forcing Visualization using bifurcation diagrams and Poincar\u00e9 sections Advanced Visualizations Phase portraits and Poincar\u00e9 maps reveal the complex landscape of motion\u2014transitions from order to chaos and back. Bifurcation diagrams highlight how varying a single parameter leads to dramatically different dynamics. \u00a9 2025 Physics Simulations | Investigating Forced Damped Pendulum Dynamics","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Physics Simulations body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background: linear-gradient(to right, #eef2f7, #d9e2ec); color: #2d3748; } .container { max-width: 960px; margin: 40px auto; padding: 40px; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); } h1 { font-size: 3rem; color: #1a202c; text-align: center; margin-bottom: 1rem; } h2 { font-size: 2rem; margin-top: 2rem; color: #2b6cb0; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.3rem; } p, ul { font-size: 1.125rem; line-height: 1.75; } ul { margin-left: 1.5rem; } pre { background-color: #2d3748; color: #f7fafc; padding: 20px; border-radius: 10px; overflow-x: auto; font-size: 0.95rem; } code { font-family: 'Courier New', monospace; } .plot { margin-top: 2rem; } footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #718096; } Orbital Period and Orbital Radius Motivation Kepler's Third Law reveals the elegant relationship between the square of the orbital period and the cube of the orbital radius for celestial bodies in circular orbits. This fundamental principle of astronomy allows us to understand planetary motion, calculate orbital characteristics, and grasp gravitational interactions at astronomical scales. Theoretical Foundation For a body in circular orbit, the gravitational force provides the necessary centripetal force: \\[ F = G \\cdot \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Substituting the orbital velocity \\( v = \\frac{2\\pi r}{T} \\) into the equation and solving for \\( T \\) gives: \\[ T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3 \\] This derivation highlights how orbital period depends on the radius and the mass of the central body. Python Simulation import numpy as np import plotly.graph_objs as go from plotly.offline import plot G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg radii = np.linspace(6.4e6, 4.2e7, 100) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) fig = go.Figure() fig.add_trace(go.Scatter(x=radii / 1e6, y=periods / 3600, mode='lines', name='Period')) fig.update_layout(title='Orbital Period vs Orbital Radius', xaxis_title='Orbital Radius (10\u2076 m)', yaxis_title='Orbital Period (hours)', template='plotly_white') plot(fig, filename='orbital_period_radius.html') Applications Used in calculating distances to planets and satellites Essential in designing satellite orbits and interplanetary missions Connects Newton\u2019s laws with astronomical observations Beyond Circular Orbits Kepler's Third Law can be extended to elliptical orbits using the semi-major axis in place of radius. This extension enables broader application to real-world planetary motion. Discussion Limitations: Assumes circular orbits and neglects perturbations, atmospheric drag, or relativistic effects Extensions: Elliptical orbit dynamics, non-Keplerian forces (e.g., solar radiation pressure) \u00a9 2025 Physics Simulations | Orbital Period and Radius Exploration","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Physics Simulations body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background: linear-gradient(to right, #eef2f7, #d9e2ec); color: #2d3748; } .container { max-width: 960px; margin: 40px auto; padding: 40px; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); } h1 { font-size: 3rem; color: #1a202c; text-align: center; margin-bottom: 1rem; } h2 { font-size: 2rem; margin-top: 2rem; color: #2b6cb0; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.3rem; } h3 { font-size: 1.5rem; margin-top: 1.5rem; color: #2c5282; } p, ul { font-size: 1.125rem; line-height: 1.75; } ul { margin-left: 1.5rem; } pre { background-color: #2d3748; color: #f7fafc; padding: 20px; border-radius: 10px; overflow-x: auto; font-size: 0.95rem; } code { font-family: 'Courier New', monospace; } .plot { margin: 2rem 0; } footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #718096; } Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Theoretical Foundation Cosmic Velocities Explained First Cosmic Velocity (Orbital Velocity): \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Second Cosmic Velocity (Escape Velocity): \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Third Cosmic Velocity (Interstellar Escape): This is the velocity required to leave the solar system and is influenced by the Sun's gravity. Python Simulation We compute the velocities using Python and visualize them with a dynamic bar chart. const G = 6.67430e-11; const bodies = [ {name: 'Earth', M: 5.972e24, r: 6.371e6}, {name: 'Mars', M: 6.417e23, r: 3.3895e6}, {name: 'Jupiter', M: 1.898e27, r: 6.9911e7}, ]; const names = bodies.map(b => b.name); const v1 = bodies.map(b => Math.sqrt(G * b.M / b.r)); const v2 = bodies.map(b => Math.sqrt(2 * G * b.M / b.r)); const trace1 = { x: names, y: v1, name: '1st Cosmic Velocity', type: 'bar', marker: {color: '#4299e1'} }; const trace2 = { x: names, y: v2, name: '2nd Cosmic Velocity', type: 'bar', marker: {color: '#ed8936'} }; const layout = { title: 'Cosmic Velocities of Celestial Bodies', xaxis: {title: 'Celestial Body'}, yaxis: {title: 'Velocity (m/s)'}, barmode: 'group' }; Plotly.newPlot('cosmicVelocitiesPlot', [trace1, trace2], layout); Applications Designing satellite orbits and interplanetary missions Determining launch velocities for space travel Understanding gravitational escape in different celestial environments Discussion Limitations: Assumes spherical symmetry and vacuum; neglects atmospheric drag and relativistic effects Extensions: Include effects of rotation, atmosphere, and gravity assists \u00a9 2025 Physics Simulations | Escape Velocities and Cosmic Dynamics","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83c\udf0a Wave Interference Simulation * { box-sizing: border-box; } body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f9f9f9; font-family: Arial, sans-serif; color: #333; } .container { margin: 40px 0; width: 95%; max-width: 960px; padding: 20px; background-color: #fff; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px 20px 0; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; border-radius: 6px; } .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-top: 10px; } .controls label { margin-right: 6px; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Wave Interference Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u26a1 Lorentz Force Simulation body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f4f4f4; font-family: Arial, sans-serif; } .container { width: 95%; max-width: 960px; margin: 40px 0; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2 { color: #2c3e50; } .controls { margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; } label { font-weight: bold; } input[type=\"range\"] { width: 200px; } #plot { margin-top: 30px; } pre { background: #eee; padding: 10px; border-radius: 6px; overflow-x: auto; } \u26a1 Lorentz Force: Particle Motion in a Magnetic Field \ud83d\udcd8 What\u2019s Happening? When a charged particle moves through a magnetic field, it experiences a force perpendicular to its motion. This Lorentz Force causes the particle to follow circular or helical paths. The force is given by: F = q (v \u00d7 B) Charged particles spiral in a uniform magnetic field. The radius and direction of motion depend on the charge, velocity, and field strength. \u2699\ufe0f Simulation Controls Initial vx: 5 Initial vy: 0 Initial vz: 5 Magnetic field Bz: 1 function update() { let vx = parseFloat(document.getElementById(\"vx\").value); let vy = parseFloat(document.getElementById(\"vy\").value); let vz = parseFloat(document.getElementById(\"vz\").value); let Bz = parseFloat(document.getElementById(\"Bz\").value); document.getElementById(\"vxValue\").textContent = vx; document.getElementById(\"vyValue\").textContent = vy; document.getElementById(\"vzValue\").textContent = vz; document.getElementById(\"BzValue\").textContent = Bz; const q = 1.0; // charge const m = 1.0; // mass const dt = 0.01; const N = 2000; let x = [0], y = [0], z = [0]; let vx0 = vx, vy0 = vy, vz0 = vz; for (let i = 0; i < N; i++) { // Velocity update from Lorentz force (only magnetic field Bz) let ax = (q / m) * (vy0 * Bz); let ay = (q / m) * (-vx0 * Bz); let az = 0; vx0 += ax * dt; vy0 += ay * dt; vz0 += az * dt; // Position update x.push(x[i] + vx0 * dt); y.push(y[i] + vy0 * dt); z.push(z[i] + vz0 * dt); } Plotly.newPlot('plot', [{ type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { color: 'royalblue' }, name: 'Particle Path' }], { title: 'Trajectory of Charged Particle in Magnetic Field', scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { t: 30 } }); } update();","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udcd0 Equivalent Resistance Using Graph Theory body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #f7f9fa; min-height: 100vh; } .container { max-width: 960px; background: white; padding: 40px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); border-radius: 10px; } h1, h2, h3 { color: #2c3e50; } code { background: #eee; padding: 2px 6px; border-radius: 4px; } pre { background: #f4f4f4; padding: 10px; border-radius: 6px; overflow-x: auto; } #result { font-weight: bold; color: #1e8449; } button { margin-top: 10px; padding: 10px 20px; background: #3498db; border: none; color: white; border-radius: 5px; cursor: pointer; } \ud83d\udcd0 Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Complex resistor networks can be tough to simplify using only series and parallel rules. Graph theory gives us a smarter way. Each node is a junction, and each resistor is an edge with a weight (the resistance). With graph algorithms, we can reduce even complicated networks to one resistance value\u2014fast and with automation in mind. \ud83d\udee0\ufe0f How It Works Represent the circuit as a graph (nodes and weighted edges). Find simple series (single path between 2 nodes) and merge. Find parallel connections (multiple edges between same two nodes) and merge. Repeat until only one edge remains between source and sink. \ud83d\udcc4 Pseudocode Repeat until graph cannot be simplified: For all pairs of nodes: If exactly one resistor connects them: Merge in series if part of a line If multiple resistors connect them: Merge using parallel rule: 1/R_eq = 1/R1 + 1/R2 + ... Return final edge between source and sink as equivalent resistance \ud83e\uddea Try It Out (Simple Series & Parallel Example) Here\u2019s a simple graph: Node A \u2192 B (resistor: 100 \u03a9) Node B \u2192 C (resistor: 200 \u03a9) Node A \u2192 C (parallel resistor: 300 \u03a9) \ud83d\udca1 Compute Equivalent Resistance \ud83d\udcca Efficiency & Improvements Efficient for tree-like and small cyclic graphs. Can be optimized using union-find, DFS, and sparse matrix solvers. Scaleable using networkx, scipy, or symbolic solvers. \ud83d\udcda Examples & Tests \ud83d\udd38 Series: A-B (100\u03a9), B-C (200\u03a9) \u2192 R_eq = 300\u03a9 \ud83d\udd38 Parallel: A-C (300\u03a9), via B path (100+200) \u2192 R_eq = 1 / (1/300 + 1/300) = 150\u03a9 function calculateResistance() { const R1 = 100; const R2 = 200; const R3 = 300; const seriesPath = R1 + R2; const parallel = 1 / (1 / R3 + 1 / seriesPath); document.getElementById(\"result\").innerText = `Total Equivalent Resistance: ${parallel.toFixed(2)} \u03a9`; }","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}