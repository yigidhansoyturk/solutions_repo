{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: Range vs Angle body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 1000px; padding: 0 20px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } input[type=\"range\"], input[type=\"number\"] { width: 200px; margin-right: 10px; } #controls label { font-weight: bold; margin-right: 10px; } #plot { margin-top: 20px; } pre { background: #f4f4f4; padding: 10px; overflow-x: auto; } ul { margin-top: 0; } \ud83d\ude80 Investigating Range vs Angle in Projectile Motion \ud83d\udcd8 Theoretical Foundation A projectile launched at an angle \u03b8 and initial speed v\u2080 follows a parabolic path under gravity. Assuming flat terrain and no air resistance: Range: R = (v\u2080\u00b2 * sin(2\u03b8)) / g This comes from decomposing motion into components: vx = v\u2080 * cos(\u03b8) vy = v\u2080 * sin(\u03b8) Time of flight = 2 * vy / g Range = vx * time The shape of the curve depends on angle, speed, and gravity. Maximum range occurs at 45\u00b0. \ud83e\uddea Simulation Controls Initial Velocity (v\u2080): 30 m/s Gravity (g): m/s\u00b2 Launch Height (h\u2080): meters \ud83d\udcca Graph Interpretation The plot shows how the horizontal range varies with angle for a given set of conditions. When height is zero, the range is maximized at 45\u00b0. If you increase height, this symmetry is broken. Higher velocities stretch the curve upwards. \ud83c\udf0d Real-World Considerations The model assumes: Flat launch/landing height No air resistance Still air and no spin In real scenarios, these factors matter: Air drag: slows the projectile and reduces range Launch height: longer flight time, increases range Wind: adds or subtracts from velocity Magnus effect: from spin, curves the path Such effects require numerical methods to simulate realistically. function computeRange(v0, g, angleDeg, h0) { const theta = angleDeg * Math.PI / 180; const v0x = v0 * Math.cos(theta); const v0y = v0 * Math.sin(theta); // Time of flight with height: solve quadratic const t_flight = (v0y + Math.sqrt(v0y * v0y + 2 * g * h0)) / g; return v0x * t_flight; } function updateAll() { const v0 = parseFloat(document.getElementById('v0').value); const g = parseFloat(document.getElementById('gravity').value); const h0 = parseFloat(document.getElementById('height').value); document.getElementById('v0Val').textContent = v0; const angles = []; const ranges = []; for (let theta = 0; theta <= 90; theta += 0.5) { angles.push(theta); ranges.push(computeRange(v0, g, theta, h0)); } const trace = { x: angles, y: ranges, type: 'scatter', mode: 'lines', line: { color: 'royalblue', width: 3 }, name: `v\u2080 = ${v0} m/s` }; const layout = { title: 'Range vs Angle of Projection', xaxis: { title: 'Angle (degrees)' }, yaxis: { title: 'Range (meters)' } }; Plotly.newPlot('plot', [trace], layout); } updateAll();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #2d3436; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } pre { background-color: #f4f4f4; padding: 10px; overflow-x: auto; } code { font-family: Consolas, monospace; } .control-group { margin-bottom: 10px; } label { font-weight: bold; } #plot { margin-top: 20px; } \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 Theoretical Foundation The equation governing a forced damped pendulum is: MathJax.Hub.Queue([\"Typeset\", MathJax.Hub]); document.getElementById(\"equation\").innerHTML = '\\\\( \\\\frac{d^2\\\\theta}{dt^2} + \\\\gamma \\\\frac{d\\\\theta}{dt} + \\\\omega_0^2 \\\\sin(\\\\theta) = A \\\\cos(\\\\omega t) \\\\)'; Where: \\\\( \\\\gamma \\\\) : damping coefficient \\\\( \\\\omega_0 \\\\) : natural frequency \\\\( A \\\\) : driving amplitude \\\\( \\\\omega \\\\) : driving frequency This second-order nonlinear differential equation exhibits behaviors ranging from periodic motion to chaos. \ud83e\uddea Simulation Controls Damping Coefficient (\\\\( \\\\gamma \\\\)): 0.2 Driving Amplitude (\\\\( A \\\\)): 1 Driving Frequency (\\\\( \\\\omega \\\\)): 1.5 \ud83d\udcc8 Dynamics & Visualizations The graph above illustrates the angular displacement of a forced damped pendulum over time. Depending on your parameter choices, you may observe: Simple harmonic motion Resonant amplification Chaotic dynamics function simulate() { const gamma = parseFloat(document.getElementById('gamma').value); const A = parseFloat(document.getElementById('A').value); const omega = parseFloat(document.getElementById('omega').value); document.getElementById('gammaVal').textContent = gamma; document.getElementById('AVal').textContent = A; document.getElementById('omegaVal').textContent = omega; let t = [], theta = [], w = 0, angle = 0, dt = 0.05; let maxT = 50; for (let time = 0; time <= maxT; time += dt) { let dw = -gamma * w - Math.sin(angle) + A * Math.cos(omega * time); w += dw * dt; angle += w * dt; t.push(time); theta.push(angle); } const trace = { x: t, y: theta, mode: 'lines', line: { color: 'crimson' }, name: 'Theta(t)' }; const layout = { title: 'Forced Damped Pendulum Motion', xaxis: { title: 'Time (s)' }, yaxis: { title: 'Angular Displacement (rad)' } }; Plotly.newPlot('plot', [trace], layout); } simulate();","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Physics Simulations body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background: linear-gradient(to right, #eef2f7, #d9e2ec); color: #2d3748; } .container { max-width: 960px; margin: 40px auto; padding: 40px; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); } h1 { font-size: 3rem; color: #1a202c; text-align: center; margin-bottom: 1rem; } h2 { font-size: 2rem; margin-top: 2rem; color: #2b6cb0; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.3rem; } p, ul { font-size: 1.125rem; line-height: 1.75; } ul { margin-left: 1.5rem; } pre { background-color: #2d3748; color: #f7fafc; padding: 20px; border-radius: 10px; overflow-x: auto; font-size: 0.95rem; } code { font-family: 'Courier New', monospace; } .plot { margin-top: 2rem; } footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #718096; } Orbital Period and Orbital Radius Motivation Kepler's Third Law reveals the elegant relationship between the square of the orbital period and the cube of the orbital radius for celestial bodies in circular orbits. This fundamental principle of astronomy allows us to understand planetary motion, calculate orbital characteristics, and grasp gravitational interactions at astronomical scales. Theoretical Foundation For a body in circular orbit, the gravitational force provides the necessary centripetal force: \\[ F = G \\cdot \\frac{Mm}{r^2} = \\frac{mv^2}{r} \\] Substituting the orbital velocity \\( v = \\frac{2\\pi r}{T} \\) into the equation and solving for \\( T \\) gives: \\[ T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3 \\] This derivation highlights how orbital period depends on the radius and the mass of the central body. Python Simulation import numpy as np import plotly.graph_objs as go from plotly.offline import plot G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg radii = np.linspace(6.4e6, 4.2e7, 100) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) fig = go.Figure() fig.add_trace(go.Scatter(x=radii / 1e6, y=periods / 3600, mode='lines', name='Period')) fig.update_layout(title='Orbital Period vs Orbital Radius', xaxis_title='Orbital Radius (10\u2076 m)', yaxis_title='Orbital Period (hours)', template='plotly_white') plot(fig, filename='orbital_period_radius.html') Applications Used in calculating distances to planets and satellites Essential in designing satellite orbits and interplanetary missions Connects Newton\u2019s laws with astronomical observations Beyond Circular Orbits Kepler's Third Law can be extended to elliptical orbits using the semi-major axis in place of radius. This extension enables broader application to real-world planetary motion. Discussion Limitations: Assumes circular orbits and neglects perturbations, atmospheric drag, or relativistic effects Extensions: Elliptical orbit dynamics, non-Keplerian forces (e.g., solar radiation pressure) \u00a9 2025 Physics Simulations | Orbital Period and Radius Exploration","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Physics Simulations body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background: linear-gradient(to right, #eef2f7, #d9e2ec); color: #2d3748; } .container { max-width: 960px; margin: 40px auto; padding: 40px; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); } h1 { font-size: 3rem; color: #1a202c; text-align: center; margin-bottom: 1rem; } h2 { font-size: 2rem; margin-top: 2rem; color: #2b6cb0; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.3rem; } h3 { font-size: 1.5rem; margin-top: 1.5rem; color: #2c5282; } p, ul { font-size: 1.125rem; line-height: 1.75; } ul { margin-left: 1.5rem; } pre { background-color: #2d3748; color: #f7fafc; padding: 20px; border-radius: 10px; overflow-x: auto; font-size: 0.95rem; } code { font-family: 'Courier New', monospace; } .plot { margin: 2rem 0; } footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #718096; } Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Theoretical Foundation Cosmic Velocities Explained First Cosmic Velocity (Orbital Velocity): \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Second Cosmic Velocity (Escape Velocity): \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Third Cosmic Velocity (Interstellar Escape): This is the velocity required to leave the solar system and is influenced by the Sun's gravity. Python Simulation We compute the velocities using Python and visualize them with a dynamic bar chart. const G = 6.67430e-11; const bodies = [ {name: 'Earth', M: 5.972e24, r: 6.371e6}, {name: 'Mars', M: 6.417e23, r: 3.3895e6}, {name: 'Jupiter', M: 1.898e27, r: 6.9911e7}, ]; const names = bodies.map(b => b.name); const v1 = bodies.map(b => Math.sqrt(G * b.M / b.r)); const v2 = bodies.map(b => Math.sqrt(2 * G * b.M / b.r)); const trace1 = { x: names, y: v1, name: '1st Cosmic Velocity', type: 'bar', marker: {color: '#4299e1'} }; const trace2 = { x: names, y: v2, name: '2nd Cosmic Velocity', type: 'bar', marker: {color: '#ed8936'} }; const layout = { title: 'Cosmic Velocities of Celestial Bodies', xaxis: {title: 'Celestial Body'}, yaxis: {title: 'Velocity (m/s)'}, barmode: 'group' }; Plotly.newPlot('cosmicVelocitiesPlot', [trace1, trace2], layout); Applications Designing satellite orbits and interplanetary missions Determining launch velocities for space travel Understanding gravitational escape in different celestial environments Discussion Limitations: Assumes spherical symmetry and vacuum; neglects atmospheric drag and relativistic effects Extensions: Include effects of rotation, atmosphere, and gravity assists \u00a9 2025 Physics Simulations | Escape Velocities and Cosmic Dynamics","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83c\udf0a Wave Interference Simulation * { box-sizing: border-box; } body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f9f9f9; font-family: Arial, sans-serif; color: #333; } .container { margin: 40px 0; width: 95%; max-width: 960px; padding: 20px; background-color: #fff; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px 20px 0; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; border-radius: 6px; } .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-top: 10px; } .controls label { margin-right: 6px; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Wave Interference Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u26a1 Lorentz Force Simulation body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f4f4f4; font-family: Arial, sans-serif; } .container { width: 95%; max-width: 960px; margin: 40px 0; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2 { color: #2c3e50; } .controls { margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; } label { font-weight: bold; } input[type=\"range\"] { width: 200px; } #plot { margin-top: 30px; } pre { background: #eee; padding: 10px; border-radius: 6px; overflow-x: auto; } \u26a1 Lorentz Force: Particle Motion in a Magnetic Field \ud83d\udcd8 What\u2019s Happening? When a charged particle moves through a magnetic field, it experiences a force perpendicular to its motion. This Lorentz Force causes the particle to follow circular or helical paths. The force is given by: F = q (v \u00d7 B) Charged particles spiral in a uniform magnetic field. The radius and direction of motion depend on the charge, velocity, and field strength. \u2699\ufe0f Simulation Controls Initial vx: 5 Initial vy: 0 Initial vz: 5 Magnetic field Bz: 1 function update() { let vx = parseFloat(document.getElementById(\"vx\").value); let vy = parseFloat(document.getElementById(\"vy\").value); let vz = parseFloat(document.getElementById(\"vz\").value); let Bz = parseFloat(document.getElementById(\"Bz\").value); document.getElementById(\"vxValue\").textContent = vx; document.getElementById(\"vyValue\").textContent = vy; document.getElementById(\"vzValue\").textContent = vz; document.getElementById(\"BzValue\").textContent = Bz; const q = 1.0; // charge const m = 1.0; // mass const dt = 0.01; const N = 2000; let x = [0], y = [0], z = [0]; let vx0 = vx, vy0 = vy, vz0 = vz; for (let i = 0; i < N; i++) { // Velocity update from Lorentz force (only magnetic field Bz) let ax = (q / m) * (vy0 * Bz); let ay = (q / m) * (-vx0 * Bz); let az = 0; vx0 += ax * dt; vy0 += ay * dt; vz0 += az * dt; // Position update x.push(x[i] + vx0 * dt); y.push(y[i] + vy0 * dt); z.push(z[i] + vz0 * dt); } Plotly.newPlot('plot', [{ type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { color: 'royalblue' }, name: 'Particle Path' }], { title: 'Trajectory of Charged Particle in Magnetic Field', scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { t: 30 } }); } update();","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udcd0 Equivalent Resistance Using Graph Theory body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #f7f9fa; min-height: 100vh; } .container { max-width: 960px; background: white; padding: 40px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); border-radius: 10px; } h1, h2, h3 { color: #2c3e50; } #result { font-weight: bold; color: #1e8449; } button { margin-top: 10px; padding: 10px 20px; background: #3498db; border: none; color: white; border-radius: 5px; cursor: pointer; } #circuitGraph { margin-top: 30px; } \ud83d\udcd0 Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Calculating equivalent resistance is crucial in understanding how electrical circuits behave. Traditional methods using only series and parallel resistor rules can become challenging with complex networks. Graph theory offers a structured, algorithmic approach. In graph theory, we treat each junction as a node and each resistor as an edge with a weight (resistance). By merging resistors using logical rules based on connectivity, we simplify the network into a single equivalent resistance efficiently. \ud83d\udee0\ufe0f How It Works Draw the circuit as a graph using nodes and resistors (edges with weights). Combine resistors in series\u2014when there's a single path between two junctions. Combine resistors in parallel\u2014when multiple resistors connect the same two junctions. Repeat the simplification process until one edge remains representing total resistance. \ud83e\uddea Try It Out (Simple Series & Parallel Example) This example shows a basic circuit with three resistors: Resistor 1: Node A \u2192 B (100 \u03a9) Resistor 2: Node B \u2192 C (200 \u03a9) Resistor 3: Node A \u2192 C (300 \u03a9, in parallel with the A\u2192B\u2192C path) We will compute the total resistance from Node A to Node C using both paths (series and parallel). \ud83d\udca1 Compute Equivalent Resistance \ud83d\udcca Efficiency & Improvements Optimized for acyclic graphs and can handle simple cycles. Further optimized using union-find, DFS, or matrix-based solvers. Adaptable to large-scale simulations using network analysis libraries. \ud83d\udcda Examples & Tests \ud83d\udd38 Series: A-B (100\u03a9), B-C (200\u03a9) \u2192 R_eq = 300\u03a9 \ud83d\udd38 Parallel: A-C (300\u03a9) in parallel with A-B-C path (100\u03a9 + 200\u03a9) \u2192 R_eq = 150\u03a9 function calculateResistance() { const R1 = 100; const R2 = 200; const R3 = 300; const seriesPath = R1 + R2; const parallel = 1 / (1 / R3 + 1 / seriesPath); document.getElementById(\"result\").innerText = `Total Equivalent Resistance: ${parallel.toFixed(2)} \u03a9`; } const nodes = [ { id: 'A', x: 0, y: 1 }, { id: 'B', x: 1, y: 1 }, { id: 'C', x: 2, y: 0.5 }, ]; const edges = [ { from: 'A', to: 'B', value: 100 }, { from: 'B', to: 'C', value: 200 }, { from: 'A', to: 'C', value: 300 }, ]; const edgeTraces = edges.map(edge => { const fromNode = nodes.find(n => n.id === edge.from); const toNode = nodes.find(n => n.id === edge.to); return { type: 'scatter', x: [fromNode.x, toNode.x], y: [fromNode.y, toNode.y], mode: 'lines+text', line: { width: 2 }, text: [`${edge.value}\u03a9`], textposition: 'top center', hoverinfo: 'none', showlegend: false }; }); const nodeTrace = { type: 'scatter', mode: 'markers+text', x: nodes.map(n => n.x), y: nodes.map(n => n.y), marker: { size: 16, color: '#2980b9' }, text: nodes.map(n => n.id), textposition: 'bottom center', hoverinfo: 'text' }; const layout = { title: 'Resistor Network Visualization', margin: { t: 50 }, xaxis: { visible: false }, yaxis: { visible: false }, height: 400 }; Plotly.newPlot('circuitGraph', [...edgeTraces, nodeTrace], layout);","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Central Limit Theorem Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; display: flex; justify-content: center; align-items: center; padding: 40px; } .container { background-color: #ffffff; padding: 30px; border-radius: 10px; box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1000px; } h1, h2 { color: #2c3e50; margin-bottom: 10px; } p { margin-bottom: 15px; line-height: 1.6; } select, input { margin-right: 10px; padding: 6px 12px; border-radius: 5px; border: 1px solid #ccc; } button { background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; } canvas { max-width: 100%; margin-top: 30px; } \ud83d\udcca Exploring the Central Limit Theorem Welcome! This interactive tool is designed to help you understand one of the most important ideas in statistics \u2014 the Central Limit Theorem (CLT). The CLT explains why many distributions in the real world tend to be normal (bell-shaped) when we average things out. Whether we are measuring manufacturing defects, average scores, or experimental results, the mean of those measurements will often look normal \u2014 even if the original data does not. Use the options below to select a population distribution and simulate the process of sampling from it. You\u2019ll observe how the sample means begin to form a normal distribution as you increase the sample size. \ud83c\udfaf Choose Distribution and Parameters Population Type: Uniform Exponential Binomial Sample Size: Samples Count: Run Simulation \ud83e\udde0 Why This Matters This interactive visualization shows how sample means form a normal distribution even when starting from highly skewed or discrete populations. The CLT underpins confidence intervals, hypothesis testing, and is vital in statistical modeling. function generatePopulation(dist, size) { const data = []; if (dist === 'uniform') { for (let i = 0; i < size; i++) data.push(Math.random()); } else if (dist === 'exponential') { for (let i = 0; i < size; i++) data.push(-Math.log(1 - Math.random())); } else if (dist === 'binomial') { for (let i = 0; i < size; i++) { let sum = 0; for (let j = 0; j < 10; j++) sum += Math.random() < 0.5 ? 1 : 0; data.push(sum); } } return data; } function simulate() { const distribution = document.getElementById('distribution').value; const sampleSize = parseInt(document.getElementById('sampleSize').value); const samples = parseInt(document.getElementById('samples').value); const means = []; for (let i = 0; i < samples; i++) { const pop = generatePopulation(distribution, sampleSize); const mean = pop.reduce((a, b) => a + b, 0) / sampleSize; means.push(mean); } const ctx = document.getElementById('histogram').getContext('2d'); if (window.histChart) window.histChart.destroy(); const bins = 40; const min = Math.min(...means); const max = Math.max(...means); const step = (max - min) / bins; const labels = Array.from({ length: bins }, (_, i) => (min + i * step).toFixed(2)); const frequencies = Array(bins).fill(0); means.forEach(m => { const index = Math.min(Math.floor((m - min) / step), bins - 1); frequencies[index]++; }); window.histChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Sample Means', data: frequencies, backgroundColor: 'rgba(52, 152, 219, 0.5)', borderColor: 'rgba(41, 128, 185, 1)', borderWidth: 1 }] }, options: { scales: { x: { title: { display: true, text: 'Sample Mean' } }, y: { title: { display: true, text: 'Frequency' } } }, plugins: { title: { display: true, text: `Sampling Distribution of the Mean (${distribution})` } } } }); const avg = (means.reduce((a, b) => a + b, 0) / samples).toFixed(3); const variance = (means.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples).toFixed(3); document.getElementById('summary').innerText = `Average of sample means: ${avg}, Variance: ${variance}`; }","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}