{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion: Range vs Angle body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 1000px; padding: 0 20px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } input[type=\"range\"], input[type=\"number\"] { width: 200px; margin-right: 10px; } #controls label { font-weight: bold; margin-right: 10px; } #plot { margin-top: 20px; } pre { background: #f4f4f4; padding: 10px; overflow-x: auto; } ul { margin-top: 0; } /* Style for formulas to keep the size consistent */ .formula { font-size: 1.5em; font-family: 'Times New Roman', Times, serif; font-weight: bold; text-align: center; margin: 20px 0; color: #e74c3c; } /* Small formulas for inline usage */ .small-formula { font-size: 1.2em; font-family: 'Times New Roman', Times, serif; font-weight: normal; text-align: center; margin: 10px 0; color: #333; } \ud83d\ude80 Investigating Range vs Angle in Projectile Motion A projectile launched at an angle \u03b8 and initial speed v\u2080 follows a parabolic path under gravity. Assuming flat terrain and no air resistance, the horizontal range is given by the equation: \\( R = \\frac{{v_0^2 \\cdot \\sin(2\\theta)}}{g} \\) This is derived from the motion's horizontal and vertical components: \\( v_x = v_0 \\cdot \\cos(\\theta) \\) (horizontal component) \\( v_y = v_0 \\cdot \\sin(\\theta) \\) (vertical component) \\( \\text{Time of flight} = \\frac{2 \\cdot v_y}{g} \\) \\( \\text{Range} = v_x \\cdot \\text{time} \\) At an ideal launch angle of 45\u00b0, the range reaches its maximum value. We will explore how the range varies with different angles and initial velocities. \ud83e\uddea Simulation Controls Initial Velocity (v\u2080): 30 m/s Gravity (g): m/s\u00b2 Launch Height (h\u2080): meters \ud83d\udcca Graph Interpretation The plot shows how the horizontal range varies with angle for a given set of conditions. When height is zero, the range is maximized at 45\u00b0. If you increase height, this symmetry is broken. Higher velocities stretch the curve upwards. \ud83c\udf0d Real-World Considerations The model assumes: Flat launch/landing height No air resistance Still air and no spin In real scenarios, these factors matter: Air drag: slows the projectile and reduces range Launch height: longer flight time, increases range Wind: adds or subtracts from velocity Magnus effect: from spin, curves the path These effects require more complex models, typically solved numerically or via simulations. // Function to compute range based on initial velocity, gravity, launch angle, and height function computeRange(v0, g, angleDeg, h0) { const theta = angleDeg * Math.PI / 180; // Convert angle to radians const v0x = v0 * Math.cos(theta); // Horizontal velocity const v0y = v0 * Math.sin(theta); // Vertical velocity // Time of flight with height: solve the quadratic equation for time const t_flight = (v0y + Math.sqrt(v0y * v0y + 2 * g * h0)) / g; return v0x * t_flight; // Range = horizontal velocity * time of flight } // Function to update the plot based on user input function updateAll() { const v0 = parseFloat(document.getElementById('v0').value); // Get velocity from input const g = parseFloat(document.getElementById('gravity').value); // Get gravity from input const h0 = parseFloat(document.getElementById('height').value); // Get height from input document.getElementById('v0Val').textContent = v0; // Update displayed value of v\u2080 const angles = []; // Array for angles const ranges = []; // Array for corresponding ranges // Calculate the range for angles from 0\u00b0 to 90\u00b0 (in increments of 0.5\u00b0) for (let theta = 0; theta <= 90; theta += 0.5) { angles.push(theta); ranges.push(computeRange(v0, g, theta, h0)); } // Plot the range vs angle const trace = { x: angles, y: ranges, type: 'scatter', mode: 'lines', line: { color: 'royalblue', width: 3 }, name: `v\u2080 = ${v0} m/s` }; // Plot layout const layout = { title: 'Range vs Angle of Projection', xaxis: { title: 'Angle (degrees)' }, yaxis: { title: 'Range (meters)' } }; Plotly.newPlot('plot', [trace], layout); // Plot using Plotly } // Initialize the plot with default values updateAll();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Simulator body { font-family: Arial, sans-serif; margin: 0 auto; max-width: 1000px; padding: 20px; background-color: #fefefe; color: #333; line-height: 1.6; overflow-x: hidden; /* Sayfa kaymas\u0131n\u0131 engellemek i\u00e7in */ } h1, h2, h3 { color: #2c3e50; } .controls input { margin: 5px 10px; } .scenario-btn { margin: 15px 5px; padding: 8px 15px; cursor: pointer; background-color: #f0f0f0; border: 1px solid #ccc; font-size: 14px; } #plot { margin-top: 30px; } code { background: #f4f4f4; padding: 3px 6px; border-radius: 4px; } h2 { font-size: 1.4em; /* Ba\u015fl\u0131k boyutunu k\u00fc\u00e7\u00fcltme */ } .scenario-btn { font-size: 16px; } \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 Theoretical Foundation The forced damped pendulum is governed by the nonlinear second-order differential equation: \\( \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\) Here: \\( \\theta \\) : Angular displacement \\( b \\) : Damping coefficient \\( L \\) : Length of pendulum \\( A \\) : Driving amplitude \\( \\omega \\) : Driving angular frequency This system can exhibit a wide variety of behaviors: from simple oscillations to chaotic motion. \ud83c\udf9b Simulation Controls Damping (b): Amplitude (A): Omega (\u03c9): Length (L): \u03b8\u2080: \u03b8\u0307\u2080: Run Simulation \ud83d\udca1 Example Scenarios: Periodic (b=0.2, A=1.2, \u03c9=2.0) Resonance (b=0.05, A=0.9, \u03c9\u2248\u221a(g/L)) Chaotic (b=0.1, A=1.5, \u03b8\u2080=1.5) \ud83d\udcca What You See on the Graph The plot below shows the angular displacement \\( \\theta(t) \\) over time, based on the chosen parameters. By changing the damping, driving amplitude, and frequency, you can observe transitions between regular and chaotic motion. function pendulumODE(t, state, b, g, L, A, omega) { const [theta, v] = state; return [v, -b * v - (g / L) * Math.sin(theta) + A * Math.cos(omega * t)]; } function rungeKutta(f, y0, t0, dt, steps, params) { let t = t0; let y = y0; const result = [[t, ...y]]; for (let i = 0; i < steps; i++) { const k1 = f(t, y, ...params); const k2 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k1[j]), ...params); const k3 = f(t + dt / 2, y.map((yi, j) => yi + dt / 2 * k2[j]), ...params); const k4 = f(t + dt, y.map((yi, j) => yi + dt * k3[j]), ...params); y = y.map((yi, j) => yi + dt / 6 * (k1[j] + 2*k2[j] + 2*k3[j] + k4[j])); t += dt; result.push([t, ...y]); } return result; } function runSimulation() { const b = parseFloat(document.getElementById('b').value); const A = parseFloat(document.getElementById('A').value); const omega = parseFloat(document.getElementById('omega').value); const L = parseFloat(document.getElementById('L').value); const theta0 = parseFloat(document.getElementById('theta0').value); const v0 = parseFloat(document.getElementById('v0').value); const data = rungeKutta(pendulumODE, [theta0, v0], 0, 0.05, 1000, [b, 9.81, L, A, omega]); const t = data.map(d => d[0]); const theta = data.map(d => d[1]); Plotly.newPlot('plot', [{ x: t, y: theta, type: 'scatter', mode: 'lines', line: { color: 'blue' } }], { title: 'Angular Displacement Over Time', xaxis: { title: 'Time (s)' }, yaxis: { title: '\u03b8 (rad)' } }); } function loadScenario(type) { if (type === 'periodic') { document.getElementById('b').value = 0.2; document.getElementById('A').value = 1.2; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"This example shows periodic behavior with light damping and moderate forcing. The pendulum synchronizes with the driving force.\"; } else if (type === 'resonance') { document.getElementById('b').value = 0.05; document.getElementById('A').value = 0.9; document.getElementById('omega').value = 3.13; document.getElementById('theta0').value = 0.2; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"Here the driving frequency matches the system's natural frequency, causing resonance and increasing amplitude dramatically.\"; } else if (type === 'chaotic') { document.getElementById('b').value = 0.1; document.getElementById('A').value = 1.5; document.getElementById('omega').value = 2.0; document.getElementById('theta0').value = 1.5; document.getElementById('v0').value = 0.0; document.getElementById('description').innerText = \"With strong forcing and large initial angle, the motion becomes chaotic. Even tiny changes lead to very different outcomes.\"; } runSimulation(); } runSimulation();","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Understanding Kepler's Third Law @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap'); body { font-family: 'Roboto', sans-serif; line-height: 1.6; margin: 0; padding: 0; background: linear-gradient(to right, #e0f7fa, #f3e5f5); color: #333; } header { background: linear-gradient(to right, #1a237e, #3949ab); color: white; text-align: center; padding: 40px 20px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } header h1 { font-size: 2.5em; margin-bottom: 10px; } header p { font-size: 1.2em; opacity: 0.9; } section { background: white; margin: 30px auto; padding: 30px; max-width: 900px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); } h2 { color: #512da8; margin-top: 0; } p { font-size: 1.1em; } canvas { display: block; margin: 30px auto; background: #fefefe; border: 2px dashed #b39ddb; border-radius: 8px; } footer { text-align: center; padding: 20px; background-color: #ede7f6; font-size: 0.9em; color: #555; } Understanding Kepler's Third Law of Planetary Motion A deep dive into the connection between orbital period and orbital radius Kepler's Third Law Explained Kepler's Third Law states that the square of the orbital period (T) of a planet is proportional to the cube of the semi-major axis (r) of its orbit: T 2 \u221d r 3 . This means that if you know how far a planet is from the object it is orbiting, you can predict how long it will take to complete one orbit. In the case of circular orbits, this relationship can be derived precisely from Newtonian mechanics. Let\u2019s derive the law using the balance between centripetal force and gravitational force. The gravitational force between two objects is F = GMm/r 2 , and the centripetal force required to keep a mass in circular motion is F = mv 2 /r . Setting these equal gives: mv 2 /r = GMm/r 2 Solving for velocity v and substituting v = 2\u03c0r/T , we find: T 2 = (4\u03c0 2 /GM)r 3 This is Kepler\u2019s Third Law for circular orbits. Visualizing Orbits and the Law The following graphic represents three different orbits around a central body. The sizes are scaled to show increasing orbital radii. In each orbit, the period increases with distance according to Kepler's Third Law. const canvas = document.getElementById(\"orbitCanvas\"); const ctx = canvas.getContext(\"2d\"); function drawSystem() { ctx.clearRect(0, 0, canvas.width, canvas.height); const centerX = canvas.width / 2; const centerY = canvas.height / 2; // Draw central star ctx.beginPath(); ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI); ctx.fillStyle = \"orange\"; ctx.fill(); const orbits = [ { radius: 60, color: \"#ef5350\", label: \"Planet A\" }, { radius: 120, color: \"#66bb6a\", label: \"Planet B\" }, { radius: 180, color: \"#42a5f5\", label: \"Planet C\" } ]; orbits.forEach((orbit, i) => { ctx.beginPath(); ctx.arc(centerX, centerY, orbit.radius, 0, 2 * Math.PI); ctx.strokeStyle = orbit.color; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); const angle = Math.PI / 4; const x = centerX + orbit.radius * Math.cos(angle); const y = centerY + orbit.radius * Math.sin(angle); ctx.beginPath(); ctx.arc(x, y, 6, 0, 2 * Math.PI); ctx.fillStyle = orbit.color; ctx.fill(); ctx.font = \"14px Roboto\"; ctx.fillStyle = \"#333\"; ctx.fillText(orbit.label, x + 10, y); }); } drawSystem(); Extension to Elliptical Orbits While the derivation above assumes circular orbits, Kepler originally observed his law in elliptical orbits. In these cases, the semi-major axis of the ellipse replaces the radius. The law still holds: the time it takes for a planet to orbit is related to the size of its orbit, regardless of its shape. This generalization is powerful because most celestial bodies, including comets and some moons, follow elliptical paths. Applications in Astronomy Kepler's Third Law allows scientists to measure the masses of distant planets and stars. For example, if the period and radius of a moon orbiting a planet are known, the mass of the planet can be calculated. This method is commonly used in both our Solar System and in distant exoplanetary systems. It also provides critical information for space missions, satellite placements, and understanding gravitational fields in a system. Real-World Examples The Moon orbits Earth at a distance of about 384,000 km and completes one orbit approximately every 27.3 days. Plugging these values into Kepler\u2019s formula provides a close approximation of Earth's mass. Similarly, planets in our Solar System obey Kepler\u2019s law. For example, Jupiter, being much farther from the Sun than Earth, has an orbital period of about 12 Earth years. Simulating Orbits Below is a simulation verifying the T 2 \u221d r 3 relationship for different orbital radii. Open your browser's developer console to view the output. function verifyKeplerLaw() { const G = 6.67430e-11; const M = 5.972e24; const results = []; for (let r = 1e7; r <= 5e7; r += 1e7) { let T = 2 * Math.PI * Math.sqrt(r ** 3 / (G * M)); results.push({ radius_km: r / 1000, period_sec: T, period_days: T / (60 * 60 * 24), T2_over_r3: (T ** 2) / (r ** 3) }); } console.log(\"Kepler's Law Simulation:\", results); } verifyKeplerLaw(); \u00a9 2025 Kepler's Third Law Educational Site","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Cosmic Velocities Explained body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f0f4f8; color: #333; } header { background-color: #003366; color: white; padding: 1em; text-align: center; } section { padding: 2em; max-width: 900px; margin: auto; background: white; margin-top: 1em; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); } h2 { color: #003366; } .chart-container { text-align: center; margin-top: 2em; } img { max-width: 100%; border-radius: 8px; } footer { text-align: center; padding: 1em; background-color: #003366; color: white; margin-top: 2em; } Understanding Cosmic Velocities 1. Definition of Cosmic Velocities First Cosmic Velocity: This is the minimum velocity needed to place an object into orbit around a celestial body, such as a satellite around Earth. For Earth, it's approximately 7.9 km/s. Second Cosmic Velocity (Escape Velocity): This is the speed required to break free from a planet\u2019s gravitational field without further propulsion. For Earth, it's about 11.2 km/s. Third Cosmic Velocity: This is the minimum speed needed to escape the gravitational pull of the Sun and leave the solar system. From Earth, this is around 16.7 km/s. 2. Mathematical Analysis These velocities derive from Newtonian mechanics and the conservation of energy. The general formula for escape velocity is: v = sqrt(2GM/R) Where: G is the gravitational constant (6.674\u00d710 \u221211 m\u00b3/kg/s\u00b2) M is the mass of the celestial body R is the radius from the center of the body 3. Velocities for Different Celestial Bodies Celestial Body First Cosmic Velocity (km/s) Second Cosmic Velocity (km/s) Third Cosmic Velocity (km/s) Earth 7.9 11.2 16.7 Mars 3.6 5.0 15.0 Jupiter 18.5 60.2 30.0 Graphical Representation 4. Importance in Space Exploration Understanding cosmic velocities is fundamental for space missions: Satellites: Launched at first cosmic velocity to maintain orbit. Moon/Mars Missions: Use second cosmic velocity to leave Earth\u2019s gravity. Interstellar Probes: Require third cosmic velocity to leave the solar system, such as the Voyager missions. \u00a9 2025 Cosmic Velocity Project | Educational Purpose","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83c\udf0a Wave Interference Simulation * { box-sizing: border-box; } body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f9f9f9; font-family: Arial, sans-serif; color: #333; } .container { margin: 40px 0; width: 95%; max-width: 960px; padding: 20px; background-color: #fff; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px 20px 0; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; border-radius: 6px; } .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-top: 10px; } .controls label { margin-right: 6px; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Wave Interference Simulation body { font-family: Arial, sans-serif; margin: 40px auto; max-width: 960px; background-color: #fefefe; color: #333; line-height: 1.6; } h1, h2, h3 { color: #2c3e50; } #plot { margin-top: 30px; } label { font-weight: bold; } input { margin-bottom: 10px; } button { margin: 10px 5px; padding: 6px 12px; font-size: 14px; border: none; background-color: #3498db; color: white; border-radius: 6px; cursor: pointer; } button:hover { background-color: #2980b9; } pre { background-color: #eee; padding: 10px; overflow-x: auto; } \ud83c\udf0a Interference Patterns from Multiple Wave Sources \ud83d\udcd6 What\u2019s Going On Here? Multiple circular wave sources on a flat surface create fascinating interference patterns. When these waves overlap, they interact based on the superposition principle \u2014 adding their amplitudes at every point in space. \u03b7(x, y, t) = (A / \u221ar) * cos(k * r - \u03c9 * t) This formula means waves decrease in amplitude as they travel (1/\u221ar), oscillate with distance and time, and interact with each other. You'll see areas of: Constructive interference (bright spots) Destructive interference (dark spots) \ud83d\udee0\ufe0f Controls Number of Sources: 6 Amplitude: 1.0 \u23ef\ufe0f Pause/Resume \ud83d\udcf8 Export as PNG const size = 100; const res = 100; const \u03bb = 10; const k = 2 * Math.PI / \u03bb; const f = 1; const \u03c9 = 2 * Math.PI * f; const x = Array.from({ length: res }, (_, i) => -size / 2 + i * size / res); const y = Array.from({ length: res }, (_, j) => -size / 2 + j * size / res); let t = 0; let interval = null; let isPaused = false; function generateSources(n) { const R = 20; const sources = []; for (let i = 0; i < n; i++) { const \u03b8 = 2 * Math.PI * i / n; sources.push([R * Math.cos(\u03b8), R * Math.sin(\u03b8)]); } return sources; } function calculateFrame(A, sources, t) { const z = []; for (let j = 0; j < y.length; j++) { const row = []; for (let i = 0; i < x.length; i++) { let sum = 0; for (const [sx, sy] of sources) { const dx = x[i] - sx; const dy = y[j] - sy; const r = Math.sqrt(dx * dx + dy * dy) + 0.001; sum += (A / Math.sqrt(r)) * Math.cos(k * r - \u03c9 * t); } row.push(sum); } z.push(row); } return z; } function updateSettings() { const N = parseInt(document.getElementById(\"numSources\").value); const A = parseFloat(document.getElementById(\"amplitude\").value); document.getElementById(\"numSourcesValue\").textContent = N; document.getElementById(\"amplitudeValue\").textContent = A.toFixed(1); startAnimation(N, A); } function startAnimation(N, A) { const sources = generateSources(N); if (interval) clearInterval(interval); interval = setInterval(() => { if (isPaused) return; const z = calculateFrame(A, sources, t); Plotly.newPlot('plot', [{ z: z, x: x, y: y, type: 'contour', contours: { coloring: 'heatmap' }, colorbar: { title: 'Amplitude' } }], { title: `Wave Interference with ${N} Sources`, xaxis: { title: 'X', scaleanchor: 'y' }, yaxis: { title: 'Y' } }); t += 0.1; }, 100); } function toggleAnimation() { isPaused = !isPaused; } function exportImage() { Plotly.toImage(document.getElementById('plot'), { format: 'png', height: 600, width: 700 }) .then(dataUrl => { const a = document.createElement('a'); a.href = dataUrl; a.download = 'wave_interference.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }); } updateSettings();","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u26a1 Lorentz Force Simulation body { margin: 0; padding: 0; min-height: 100vh; display: flex; justify-content: center; align-items: start; background-color: #f4f4f4; font-family: Arial, sans-serif; } .container { width: 95%; max-width: 960px; margin: 40px 0; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); } h1, h2 { color: #2c3e50; } .controls { margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; } label { font-weight: bold; } input[type=\"range\"] { width: 200px; } #plot { margin-top: 30px; } pre { background: #eee; padding: 10px; border-radius: 6px; overflow-x: auto; } \u26a1 Lorentz Force: Particle Motion in a Magnetic Field \ud83d\udcd8 What\u2019s Happening? When a charged particle moves through a magnetic field, it experiences a force perpendicular to its motion. This Lorentz Force causes the particle to follow circular or helical paths. The force is given by: F = q (v \u00d7 B) Charged particles spiral in a uniform magnetic field. The radius and direction of motion depend on the charge, velocity, and field strength. \u2699\ufe0f Simulation Controls Initial vx: 5 Initial vy: 0 Initial vz: 5 Magnetic field Bz: 1 function update() { let vx = parseFloat(document.getElementById(\"vx\").value); let vy = parseFloat(document.getElementById(\"vy\").value); let vz = parseFloat(document.getElementById(\"vz\").value); let Bz = parseFloat(document.getElementById(\"Bz\").value); document.getElementById(\"vxValue\").textContent = vx; document.getElementById(\"vyValue\").textContent = vy; document.getElementById(\"vzValue\").textContent = vz; document.getElementById(\"BzValue\").textContent = Bz; const q = 1.0; // charge const m = 1.0; // mass const dt = 0.01; const N = 2000; let x = [0], y = [0], z = [0]; let vx0 = vx, vy0 = vy, vz0 = vz; for (let i = 0; i < N; i++) { // Velocity update from Lorentz force (only magnetic field Bz) let ax = (q / m) * (vy0 * Bz); let ay = (q / m) * (-vx0 * Bz); let az = 0; vx0 += ax * dt; vy0 += ay * dt; vz0 += az * dt; // Position update x.push(x[i] + vx0 * dt); y.push(y[i] + vy0 * dt); z.push(z[i] + vz0 * dt); } Plotly.newPlot('plot', [{ type: 'scatter3d', mode: 'lines', x: x, y: y, z: z, line: { color: 'royalblue' }, name: 'Particle Path' }], { title: 'Trajectory of Charged Particle in Magnetic Field', scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { t: 30 } }); } update();","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udcd0 Equivalent Resistance Using Graph Theory body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #f7f9fa; min-height: 100vh; } .container { max-width: 960px; background: white; padding: 40px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); border-radius: 10px; } h1, h2, h3 { color: #2c3e50; } #result { font-weight: bold; color: #1e8449; } button { margin-top: 10px; padding: 10px 20px; background: #3498db; border: none; color: white; border-radius: 5px; cursor: pointer; } #circuitGraph { margin-top: 30px; } \ud83d\udcd0 Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Calculating equivalent resistance is crucial in understanding how electrical circuits behave. Traditional methods using only series and parallel resistor rules can become challenging with complex networks. Graph theory offers a structured, algorithmic approach. In graph theory, we treat each junction as a node and each resistor as an edge with a weight (resistance). By merging resistors using logical rules based on connectivity, we simplify the network into a single equivalent resistance efficiently. \ud83d\udee0\ufe0f How It Works Draw the circuit as a graph using nodes and resistors (edges with weights). Combine resistors in series\u2014when there's a single path between two junctions. Combine resistors in parallel\u2014when multiple resistors connect the same two junctions. Repeat the simplification process until one edge remains representing total resistance. \ud83e\uddea Try It Out (Simple Series & Parallel Example) This example shows a basic circuit with three resistors: Resistor 1: Node A \u2192 B (100 \u03a9) Resistor 2: Node B \u2192 C (200 \u03a9) Resistor 3: Node A \u2192 C (300 \u03a9, in parallel with the A\u2192B\u2192C path) We will compute the total resistance from Node A to Node C using both paths (series and parallel). \ud83d\udca1 Compute Equivalent Resistance \ud83d\udcca Efficiency & Improvements Optimized for acyclic graphs and can handle simple cycles. Further optimized using union-find, DFS, or matrix-based solvers. Adaptable to large-scale simulations using network analysis libraries. \ud83d\udcda Examples & Tests \ud83d\udd38 Series: A-B (100\u03a9), B-C (200\u03a9) \u2192 R_eq = 300\u03a9 \ud83d\udd38 Parallel: A-C (300\u03a9) in parallel with A-B-C path (100\u03a9 + 200\u03a9) \u2192 R_eq = 150\u03a9 function calculateResistance() { const R1 = 100; const R2 = 200; const R3 = 300; const seriesPath = R1 + R2; const parallel = 1 / (1 / R3 + 1 / seriesPath); document.getElementById(\"result\").innerText = `Total Equivalent Resistance: ${parallel.toFixed(2)} \u03a9`; } const nodes = [ { id: 'A', x: 0, y: 1 }, { id: 'B', x: 1, y: 1 }, { id: 'C', x: 2, y: 0.5 }, ]; const edges = [ { from: 'A', to: 'B', value: 100 }, { from: 'B', to: 'C', value: 200 }, { from: 'A', to: 'C', value: 300 }, ]; const edgeTraces = edges.map(edge => { const fromNode = nodes.find(n => n.id === edge.from); const toNode = nodes.find(n => n.id === edge.to); return { type: 'scatter', x: [fromNode.x, toNode.x], y: [fromNode.y, toNode.y], mode: 'lines+text', line: { width: 2 }, text: [`${edge.value}\u03a9`], textposition: 'top center', hoverinfo: 'none', showlegend: false }; }); const nodeTrace = { type: 'scatter', mode: 'markers+text', x: nodes.map(n => n.x), y: nodes.map(n => n.y), marker: { size: 16, color: '#2980b9' }, text: nodes.map(n => n.id), textposition: 'bottom center', hoverinfo: 'text' }; const layout = { title: 'Resistor Network Visualization', margin: { t: 50 }, xaxis: { visible: false }, yaxis: { visible: false }, height: 400 }; Plotly.newPlot('circuitGraph', [...edgeTraces, nodeTrace], layout);","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Central Limit Theorem Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; display: flex; justify-content: center; align-items: center; padding: 40px; } .container { background-color: #ffffff; padding: 30px; border-radius: 10px; box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1000px; } h1, h2 { color: #2c3e50; margin-bottom: 10px; } p { margin-bottom: 15px; line-height: 1.6; } select, input { margin-right: 10px; padding: 6px 12px; border-radius: 5px; border: 1px solid #ccc; } button { background-color: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; } canvas { max-width: 100%; margin-top: 30px; } \ud83d\udcca Exploring the Central Limit Theorem Welcome! This interactive tool is designed to help you understand one of the most important ideas in statistics \u2014 the Central Limit Theorem (CLT). The CLT explains why many distributions in the real world tend to be normal (bell-shaped) when we average things out. Whether we are measuring manufacturing defects, average scores, or experimental results, the mean of those measurements will often look normal \u2014 even if the original data does not. Use the options below to select a population distribution and simulate the process of sampling from it. You\u2019ll observe how the sample means begin to form a normal distribution as you increase the sample size. \ud83c\udfaf Choose Distribution and Parameters Population Type: Uniform Exponential Binomial Sample Size: Samples Count: Run Simulation \ud83e\udde0 Why This Matters This interactive visualization shows how sample means form a normal distribution even when starting from highly skewed or discrete populations. The CLT underpins confidence intervals, hypothesis testing, and is vital in statistical modeling. function generatePopulation(dist, size) { const data = []; if (dist === 'uniform') { for (let i = 0; i < size; i++) data.push(Math.random()); } else if (dist === 'exponential') { for (let i = 0; i < size; i++) data.push(-Math.log(1 - Math.random())); } else if (dist === 'binomial') { for (let i = 0; i < size; i++) { let sum = 0; for (let j = 0; j < 10; j++) sum += Math.random() < 0.5 ? 1 : 0; data.push(sum); } } return data; } function simulate() { const distribution = document.getElementById('distribution').value; const sampleSize = parseInt(document.getElementById('sampleSize').value); const samples = parseInt(document.getElementById('samples').value); const means = []; for (let i = 0; i < samples; i++) { const pop = generatePopulation(distribution, sampleSize); const mean = pop.reduce((a, b) => a + b, 0) / sampleSize; means.push(mean); } const ctx = document.getElementById('histogram').getContext('2d'); if (window.histChart) window.histChart.destroy(); const bins = 40; const min = Math.min(...means); const max = Math.max(...means); const step = (max - min) / bins; const labels = Array.from({ length: bins }, (_, i) => (min + i * step).toFixed(2)); const frequencies = Array(bins).fill(0); means.forEach(m => { const index = Math.min(Math.floor((m - min) / step), bins - 1); frequencies[index]++; }); window.histChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Sample Means', data: frequencies, backgroundColor: 'rgba(52, 152, 219, 0.5)', borderColor: 'rgba(41, 128, 185, 1)', borderWidth: 1 }] }, options: { scales: { x: { title: { display: true, text: 'Sample Mean' } }, y: { title: { display: true, text: 'Frequency' } } }, plugins: { title: { display: true, text: `Sampling Distribution of the Mean (${distribution})` } } } }); const avg = (means.reduce((a, b) => a + b, 0) / samples).toFixed(3); const variance = (means.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / samples).toFixed(3); document.getElementById('summary').innerText = `Average of sample means: ${avg}, Variance: ${variance}`; }","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}